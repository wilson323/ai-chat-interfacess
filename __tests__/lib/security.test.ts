/**
 * ÂÆâÂÖ®Ê®°ÂùóÊµãËØï
 * ÊµãËØïÂÆâÂÖ®Êâ´Êèè„ÄÅËæìÂÖ•È™åËØÅ„ÄÅÊùÉÈôêÊéßÂà∂Á≠âÂäüËÉΩ
 */

import {
  validateInput,
  sanitizeInput,
  checkPermissions,
  generateSecureToken,
  hashPassword,
  verifyPassword,
  detectXSS,
  detectSQLInjection,
  validateFileUpload,
  encryptData,
  decryptData
} from '@/lib/security';

describe('ÂÆâÂÖ®Ê®°ÂùóÊµãËØï', () => {
  describe('ËæìÂÖ•È™åËØÅÊµãËØï', () => {
    it('Â∫îËØ•È™åËØÅÊúâÊïàÁöÑËæìÂÖ•', () => {
      const validInputs = [
        'Hello World',
        'user@example.com',
        '12345',
        'normal-text-123'
      ];

      validInputs.forEach(input => {
        expect(validateInput(input, 'text')).toBe(true);
      });
    });

    it('Â∫îËØ•ÊãíÁªùÊó†ÊïàÁöÑËæìÂÖ•', () => {
      const invalidInputs = [
        '', // Á©∫Â≠óÁ¨¶‰∏≤
        '   ', // Âè™ÊúâÁ©∫Ê†º
        null,
        undefined
      ];

      invalidInputs.forEach(input => {
        expect(validateInput(input as any, 'text')).toBe(false);
      });
    });

    it('Â∫îËØ•È™åËØÅÈÇÆÁÆ±Ê†ºÂºè', () => {
      const validEmails = [
        'user@example.com',
        'test.email@domain.co.uk',
        'user+tag@example.org'
      ];

      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'user@',
        'user@.com'
      ];

      validEmails.forEach(email => {
        expect(validateInput(email, 'email')).toBe(true);
      });

      invalidEmails.forEach(email => {
        expect(validateInput(email, 'email')).toBe(false);
      });
    });

    it('Â∫îËØ•È™åËØÅURLÊ†ºÂºè', () => {
      const validUrls = [
        'https://example.com',
        'http://localhost:3000',
        'https://sub.domain.com/path?query=value'
      ];

      const invalidUrls = [
        'not-a-url',
        'ftp://example.com',
        'javascript:alert("xss")'
      ];

      validUrls.forEach(url => {
        expect(validateInput(url, 'url')).toBe(true);
      });

      invalidUrls.forEach(url => {
        expect(validateInput(url, 'url')).toBe(false);
      });
    });
  });

  describe('ËæìÂÖ•Ê∏ÖÁêÜÊµãËØï', () => {
    it('Â∫îËØ•Ê∏ÖÁêÜHTMLÊ†áÁ≠æ', () => {
      const input = '<script>alert("xss")</script>Hello World';
      const cleaned = sanitizeInput(input, 'html');
      
      expect(cleaned).toBe('Hello World');
      expect(cleaned).not.toContain('<script>');
      expect(cleaned).not.toContain('alert');
    });

    it('Â∫îËØ•Ê∏ÖÁêÜSQLÊ≥®ÂÖ•Â≠óÁ¨¶', () => {
      const input = "'; DROP TABLE users; --";
      const cleaned = sanitizeInput(input, 'sql');
      
      expect(cleaned).not.toContain('DROP');
      expect(cleaned).not.toContain('--');
      expect(cleaned).not.toContain("'");
    });

    it('Â∫îËØ•Ê∏ÖÁêÜJavaScript‰ª£Á†Å', () => {
      const input = 'Hello <img src=x onerror=alert("xss")> World';
      const cleaned = sanitizeInput(input, 'js');
      
      expect(cleaned).toBe('Hello  World');
      expect(cleaned).not.toContain('<img');
      expect(cleaned).not.toContain('onerror');
    });

    it('Â∫îËØ•‰øùÁïôÂÆâÂÖ®ÁöÑHTMLÊ†áÁ≠æ', () => {
      const input = '<p>Hello <strong>World</strong></p>';
      const cleaned = sanitizeInput(input, 'html');
      
      expect(cleaned).toContain('<p>');
      expect(cleaned).toContain('<strong>');
      expect(cleaned).toContain('Hello');
      expect(cleaned).toContain('World');
    });
  });

  describe('ÊùÉÈôêÊéßÂà∂ÊµãËØï', () => {
    const mockUser = {
      id: '1',
      role: 'admin',
      permissions: ['read', 'write', 'delete']
    };

    const mockRegularUser = {
      id: '2',
      role: 'user',
      permissions: ['read']
    };

    it('Â∫îËØ•ÂÖÅËÆ∏ÊúâÊùÉÈôêÁöÑÁî®Êà∑ËÆøÈóÆ', () => {
      expect(checkPermissions(mockUser, 'read')).toBe(true);
      expect(checkPermissions(mockUser, 'write')).toBe(true);
      expect(checkPermissions(mockUser, 'delete')).toBe(true);
    });

    it('Â∫îËØ•ÊãíÁªùÊ≤°ÊúâÊùÉÈôêÁöÑÁî®Êà∑ËÆøÈóÆ', () => {
      expect(checkPermissions(mockRegularUser, 'write')).toBe(false);
      expect(checkPermissions(mockRegularUser, 'delete')).toBe(false);
      expect(checkPermissions(mockRegularUser, 'admin')).toBe(false);
    });

    it('Â∫îËØ•Â§ÑÁêÜÁ©∫Áî®Êà∑ÂØπË±°', () => {
      expect(checkPermissions(null as any, 'read')).toBe(false);
      expect(checkPermissions(undefined as any, 'read')).toBe(false);
    });

    it('Â∫îËØ•ÊîØÊåÅËßíËâ≤ÊùÉÈôêÊ£ÄÊü•', () => {
      expect(checkPermissions(mockUser, 'admin_access')).toBe(true);
      expect(checkPermissions(mockRegularUser, 'admin_access')).toBe(false);
    });
  });

  describe('Âä†ÂØÜÂäüËÉΩÊµãËØï', () => {
    it('Â∫îËØ•ÁîüÊàêÂÆâÂÖ®ÁöÑ‰ª§Áâå', () => {
      const token1 = generateSecureToken();
      const token2 = generateSecureToken();
      
      expect(token1).toBeDefined();
      expect(token2).toBeDefined();
      expect(token1).not.toBe(token2);
      expect(token1.length).toBeGreaterThan(20);
    });

    it('Â∫îËØ•Ê≠£Á°ÆÂìàÂ∏åÂØÜÁ†Å', async () => {
      const password = 'testpassword123';
      const hash = await hashPassword(password);
      
      expect(hash).toBeDefined();
      expect(hash).not.toBe(password);
      expect(hash.length).toBeGreaterThan(50);
    });

    it('Â∫îËØ•Ê≠£Á°ÆÈ™åËØÅÂØÜÁ†Å', async () => {
      const password = 'testpassword123';
      const hash = await hashPassword(password);
      
      const isValid = await verifyPassword(password, hash);
      const isInvalid = await verifyPassword('wrongpassword', hash);
      
      expect(isValid).toBe(true);
      expect(isInvalid).toBe(false);
    });

    it('Â∫îËØ•Âä†ÂØÜÂíåËß£ÂØÜÊï∞ÊçÆ', () => {
      const originalData = { message: 'secret data', id: 123 };
      const encrypted = encryptData(originalData);
      const decrypted = decryptData(encrypted);
      
      expect(encrypted).not.toEqual(originalData);
      expect(decrypted).toEqual(originalData);
    });
  });

  describe('ÂÆâÂÖ®Ê£ÄÊµãÊµãËØï', () => {
    it('Â∫îËØ•Ê£ÄÊµãXSSÊîªÂáª', () => {
      const xssPayloads = [
        '<script>alert("xss")</script>',
        '<img src=x onerror=alert("xss")>',
        'javascript:alert("xss")',
        '<svg onload=alert("xss")>'
      ];

      xssPayloads.forEach(payload => {
        expect(detectXSS(payload)).toBe(true);
      });

      const safeInputs = [
        'Hello World',
        'Normal text with numbers 123',
        '<p>Safe HTML</p>'
      ];

      safeInputs.forEach(input => {
        expect(detectXSS(input)).toBe(false);
      });
    });

    it('Â∫îËØ•Ê£ÄÊµãSQLÊ≥®ÂÖ•ÊîªÂáª', () => {
      const sqlPayloads = [
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "'; INSERT INTO users VALUES ('hacker', 'password'); --",
        "' UNION SELECT * FROM users --"
      ];

      sqlPayloads.forEach(payload => {
        expect(detectSQLInjection(payload)).toBe(true);
      });

      const safeInputs = [
        'normal search query',
        'user@example.com',
        'John Doe'
      ];

      safeInputs.forEach(input => {
        expect(detectSQLInjection(input)).toBe(false);
      });
    });
  });

  describe('Êñá‰ª∂‰∏ä‰º†È™åËØÅÊµãËØï', () => {
    const mockFile = {
      name: 'test.txt',
      size: 1024,
      type: 'text/plain'
    };

    const mockImageFile = {
      name: 'test.jpg',
      size: 2048,
      type: 'image/jpeg'
    };

    const mockLargeFile = {
      name: 'large.txt',
      size: 10 * 1024 * 1024, // 10MB
      type: 'text/plain'
    };

    const mockExecutableFile = {
      name: 'malware.exe',
      size: 1024,
      type: 'application/x-executable'
    };

    it('Â∫îËØ•È™åËØÅÂÖÅËÆ∏ÁöÑÊñá‰ª∂Á±ªÂûã', () => {
      const result1 = validateFileUpload(mockFile, {
        allowedTypes: ['text/plain', 'text/csv'],
        maxSize: 5 * 1024 * 1024
      });

      const result2 = validateFileUpload(mockImageFile, {
        allowedTypes: ['image/jpeg', 'image/png'],
        maxSize: 5 * 1024 * 1024
      });

      expect(result1.isValid).toBe(true);
      expect(result2.isValid).toBe(true);
    });

    it('Â∫îËØ•ÊãíÁªù‰∏çÂÖÅËÆ∏ÁöÑÊñá‰ª∂Á±ªÂûã', () => {
      const result = validateFileUpload(mockExecutableFile, {
        allowedTypes: ['text/plain', 'image/jpeg'],
        maxSize: 5 * 1024 * 1024
      });

      expect(result.isValid).toBe(false);
      expect(result.error).toContain('not allowed');
    });

    it('Â∫îËØ•ÊãíÁªùËøáÂ§ßÁöÑÊñá‰ª∂', () => {
      const result = validateFileUpload(mockLargeFile, {
        allowedTypes: ['text/plain'],
        maxSize: 1024 * 1024 // 1MB
      });

      expect(result.isValid).toBe(false);
      expect(result.error).toContain('too large');
    });

    it('Â∫îËØ•È™åËØÅÊñá‰ª∂Êâ©Â±ïÂêç', () => {
      const result = validateFileUpload(mockFile, {
        allowedExtensions: ['.txt', '.csv'],
        maxSize: 5 * 1024 * 1024
      });

      expect(result.isValid).toBe(true);
    });

    it('Â∫îËØ•ÊãíÁªùÂç±Èô©ÁöÑÊñá‰ª∂Êâ©Â±ïÂêç', () => {
      const dangerousFile = {
        name: 'malware.exe',
        size: 1024,
        type: 'application/octet-stream'
      };

      const result = validateFileUpload(dangerousFile, {
        allowedExtensions: ['.txt', '.pdf'],
        maxSize: 5 * 1024 * 1024
      });

      expect(result.isValid).toBe(false);
      expect(result.error).toContain('dangerous');
    });
  });

  describe('ËæπÁïåÊù°‰ª∂ÊµãËØï', () => {
    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ËæìÂÖ•', () => {
      expect(validateInput('', 'text')).toBe(false);
      expect(sanitizeInput('', 'html')).toBe('');
      expect(checkPermissions(null as any, 'read')).toBe(false);
    });

    it('Â∫îËØ•Â§ÑÁêÜÁâπÊÆäÂ≠óÁ¨¶', () => {
      const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';
      expect(validateInput(specialChars, 'text')).toBe(true);
      expect(sanitizeInput(specialChars, 'html')).toBe(specialChars);
    });

    it('Â∫îËØ•Â§ÑÁêÜUnicodeÂ≠óÁ¨¶', () => {
      const unicodeText = 'Hello ‰∏ñÁïå üåç';
      expect(validateInput(unicodeText, 'text')).toBe(true);
      expect(sanitizeInput(unicodeText, 'html')).toBe(unicodeText);
    });

    it('Â∫îËØ•Â§ÑÁêÜÈïøËæìÂÖ•', () => {
      const longText = 'A'.repeat(10000);
      expect(validateInput(longText, 'text')).toBe(true);
      
      const cleaned = sanitizeInput(longText, 'html');
      expect(cleaned.length).toBe(10000);
    });
  });
});
---
alwaysApply: true
---

# æ•°æ®åº“å¤„ç†è§„èŒƒ

## ğŸ¯ æ•°æ®åº“æ¶æ„åŸåˆ™

### 1. æŠ€æœ¯æ ˆé€‰æ‹©
- **ORM**: Sequelize (å½“å‰) / Prisma (æ¨èå‡çº§)
- **æ•°æ®åº“**: PostgreSQL (ä¼ä¸šçº§)
- **è¿æ¥æ± **: å·²é…ç½®ï¼Œéœ€è¦ä¼˜åŒ–
- **ç¼“å­˜**: Redis (å·²é…ç½®ï¼Œéœ€è¦å……åˆ†åˆ©ç”¨)

### 2. æ•°æ®åº“è®¾è®¡åŸåˆ™
- **è§„èŒƒåŒ–**: éµå¾ªç¬¬ä¸‰èŒƒå¼ï¼Œé¿å…æ•°æ®å†—ä½™
- **æ€§èƒ½ä¼˜å…ˆ**: åˆç†ç´¢å¼•è®¾è®¡ï¼ŒæŸ¥è¯¢ä¼˜åŒ–
- **æ•°æ®å®Œæ•´æ€§**: å¤–é”®çº¦æŸï¼Œæ•°æ®ç±»å‹ä¸¥æ ¼
- **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’Œå‚ç›´æ‰©å±•

## ğŸ“Š å½“å‰æ•°æ®åº“æ–¹æ¡ˆåˆ†æ

### ç°æœ‰é…ç½®è¯„ä¼°
```typescript
// lib/db/sequelize.ts - å½“å‰é…ç½®
const sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, {
  host: DB_HOST,
  port: DB_PORT,
  dialect: 'postgres',
  pool: {
    max: 10,        // æœ€å¤§è¿æ¥æ•°
    min: 0,         // æœ€å°è¿æ¥æ•°
    acquire: 30000, // è·å–è¿æ¥è¶…æ—¶
    idle: 10000,    // ç©ºé—²è¿æ¥è¶…æ—¶
  },
  define: {
    freezeTableName: true,
    underscored: true,
  },
});
```

**é—®é¢˜è¯†åˆ«**:
- âŒ è¿æ¥æ± é…ç½®åä¿å®ˆ
- âŒ ç¼ºå°‘æŸ¥è¯¢æ€§èƒ½ç›‘æ§
- âŒ ç¼ºå°‘è¿æ¥æ± ç›‘æ§
- âŒ ç¼ºå°‘é‡è¯•æœºåˆ¶

## ğŸš€ ä¼˜åŒ–æ–¹æ¡ˆ

### 1. è¿æ¥æ± ä¼˜åŒ–

#### æ¨èé…ç½®
```typescript
const sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, {
  host: DB_HOST,
  port: DB_PORT,
  dialect: 'postgres',
  dialectModule: pg,
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  
  // ä¼˜åŒ–è¿æ¥æ± é…ç½®
  pool: {
    max: 20,        // å¢åŠ æœ€å¤§è¿æ¥æ•°
    min: 5,         // å¢åŠ æœ€å°è¿æ¥æ•°
    acquire: 30000, // è·å–è¿æ¥è¶…æ—¶
    idle: 10000,    // ç©ºé—²è¿æ¥è¶…æ—¶
    evict: 1000,    // æ¸…ç†é—´éš”
    handleDisconnects: true, // å¤„ç†æ–­å¼€è¿æ¥
  },
  
  // æ·»åŠ é‡è¯•æœºåˆ¶
  retry: {
    max: 3,         // æœ€å¤§é‡è¯•æ¬¡æ•°
    timeout: 60000, // é‡è¯•è¶…æ—¶
    match: [
      /ETIMEDOUT/,
      /EHOSTUNREACH/,
      /ECONNRESET/,
      /ECONNREFUSED/,
      /ETIMEDOUT/,
      /ESOCKETTIMEDOUT/,
      /EHOSTUNREACH/,
      /EPIPE/,
      /EAI_AGAIN/,
      /SequelizeConnectionError/,
      /SequelizeConnectionRefusedError/,
      /SequelizeHostNotFoundError/,
      /SequelizeHostNotReachableError/,
      /SequelizeInvalidConnectionError/,
      /SequelizeConnectionTimedOutError/
    ]
  },
  
  // æ€§èƒ½ç›‘æ§
  benchmark: true,
  
  // æŸ¥è¯¢ä¼˜åŒ–
  define: {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: false, // è½¯åˆ é™¤
  },
  
  // æŸ¥è¯¢ä¼˜åŒ–é…ç½®
  query: {
    raw: false,
    nest: true,
    plain: false
  }
});
```

### 2. ä½¿ç”¨æˆç†Ÿçš„æ•°æ®åº“è§£å†³æ–¹æ¡ˆ

#### æ¨èå‡çº§åˆ° Prisma
```typescript
// ä¼˜åŠ¿å¯¹æ¯”
// Sequelize: æˆç†Ÿç¨³å®šï¼Œä½†ç±»å‹æ”¯æŒæœ‰é™
// Prisma: ç±»å‹å®‰å…¨ï¼Œè‡ªåŠ¨ç”Ÿæˆå®¢æˆ·ç«¯ï¼Œæ›´å¥½çš„å¼€å‘ä½“éªŒ

// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AgentConfig {
  id            Int      @id @default(autoincrement())
  name          String
  type          String
  apiKey        String
  appId         String
  apiUrl        String?
  systemPrompt  String
  temperature   Float    @default(0.7)
  maxTokens     Int      @default(2000)
  isPublished   Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("agent_config")
}
```

#### æ•°æ®åº“è¿æ¥ç®¡ç†
```typescript
// lib/db/connection.ts
import { PrismaClient } from '@prisma/client'

class DatabaseManager {
  private static instance: PrismaClient
  private static isConnected = false

  static getInstance(): PrismaClient {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new PrismaClient({
        log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],
        errorFormat: 'pretty',
      })
    }
    return DatabaseManager.instance
  }

  static async connect(): Promise<void> {
    if (!DatabaseManager.isConnected) {
      try {
        await DatabaseManager.getInstance().$connect()
        DatabaseManager.isConnected = true
        console.log('æ•°æ®åº“è¿æ¥æˆåŠŸ')
      } catch (error) {
        console.error('æ•°æ®åº“è¿æ¥å¤±è´¥:', error)
        throw error
      }
    }
  }

  static async disconnect(): Promise<void> {
    if (DatabaseManager.isConnected) {
      await DatabaseManager.getInstance().$disconnect()
      DatabaseManager.isConnected = false
      console.log('æ•°æ®åº“è¿æ¥å·²æ–­å¼€')
    }
  }
}

export default DatabaseManager
```

### 3. æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

#### ç´¢å¼•ä¼˜åŒ–
```sql
-- ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
CREATE INDEX idx_agent_config_type ON agent_config(type);
CREATE INDEX idx_agent_config_published ON agent_config(is_published);
CREATE INDEX idx_chat_history_session_id ON chat_history(session_id);
CREATE INDEX idx_chat_history_created_at ON chat_history(created_at);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_agent_config_type_published ON agent_config(type, is_published);
```

#### æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹
```typescript
// âŒ ä¸å¥½çš„æŸ¥è¯¢
const agents = await AgentConfig.findAll({
  where: { isPublished: true },
  order: [['order', 'ASC']]
})

// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨ç´¢å¼•ï¼Œé™åˆ¶å­—æ®µ
const agents = await AgentConfig.findAll({
  attributes: ['id', 'name', 'type', 'description', 'order'],
  where: { isPublished: true },
  order: [['order', 'ASC']],
  limit: 100
})

// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨åŸå§‹SQLä¼˜åŒ–
const agents = await sequelize.query(`
  SELECT id, name, type, description, "order"
  FROM agent_config 
  WHERE is_published = true 
  ORDER BY "order" ASC 
  LIMIT 100
`, {
  type: QueryTypes.SELECT,
  raw: true
})
```

### 4. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### Redisç¼“å­˜é…ç½®
```typescript
// lib/cache/redis.ts
import Redis from 'ioredis'

class CacheManager {
  private redis: Redis

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || '0'),
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
    })

    this.redis.on('error', (err) => {
      console.error('Redisè¿æ¥é”™è¯¯:', err)
    })
  }

  // æ™ºèƒ½ä½“é…ç½®ç¼“å­˜
  async getAgentConfigs(): Promise<AgentConfig[] | null> {
    const cached = await this.redis.get('agent_configs')
    return cached ? JSON.parse(cached) : null
  }

  async setAgentConfigs(configs: AgentConfig[], ttl = 300): Promise<void> {
    await this.redis.setex('agent_configs', ttl, JSON.stringify(configs))
  }

  // ç”¨æˆ·ä¼šè¯ç¼“å­˜
  async getSession(sessionId: string): Promise<any> {
    const cached = await this.redis.get(`session:${sessionId}`)
    return cached ? JSON.parse(cached) : null
  }

  async setSession(sessionId: string, data: any, ttl = 3600): Promise<void> {
    await this.redis.setex(`session:${sessionId}`, ttl, JSON.stringify(data))
  }

  // ç¼“å­˜å¤±æ•ˆ
  async invalidateAgentConfigs(): Promise<void> {
    await this.redis.del('agent_configs')
  }
}

export default new CacheManager()
```

### 5. æ•°æ®åº“ç›‘æ§

#### æ€§èƒ½ç›‘æ§
```typescript
// lib/monitoring/database.ts
export class DatabaseMonitor {
  private static queryTimes: number[] = []
  private static errorCount = 0

  static async monitorQuery<T>(
    queryName: string,
    queryFn: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now()
    
    try {
      const result = await queryFn()
      const duration = Date.now() - startTime
      
      // è®°å½•æŸ¥è¯¢æ—¶é—´
      this.queryTimes.push(duration)
      
      // å¦‚æœæŸ¥è¯¢æ—¶é—´è¶…è¿‡1ç§’ï¼Œè®°å½•è­¦å‘Š
      if (duration > 1000) {
        console.warn(`æ…¢æŸ¥è¯¢è­¦å‘Š: ${queryName} è€—æ—¶ ${duration}ms`)
      }
      
      return result
    } catch (error) {
      this.errorCount++
      console.error(`æ•°æ®åº“æŸ¥è¯¢é”™è¯¯ [${queryName}]:`, error)
      throw error
    }
  }

  static getStats() {
    return {
      averageQueryTime: this.queryTimes.reduce((a, b) => a + b, 0) / this.queryTimes.length,
      maxQueryTime: Math.max(...this.queryTimes),
      errorCount: this.errorCount,
      totalQueries: this.queryTimes.length
    }
  }
}
```

## ğŸ“‹ æ•°æ®åº“æ“ä½œè§„èŒƒ

### 1. æŸ¥è¯¢è§„èŒƒ

#### åŸºç¡€æŸ¥è¯¢
```typescript
// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨ç±»å‹å®‰å…¨
interface GetAgentConfigsParams {
  type?: string
  isPublished?: boolean
  limit?: number
  offset?: number
}

async function getAgentConfigs(params: GetAgentConfigsParams = {}) {
  const { type, isPublished = true, limit = 100, offset = 0 } = params
  
  return await DatabaseMonitor.monitorQuery('getAgentConfigs', async () => {
    return await AgentConfig.findAll({
      attributes: ['id', 'name', 'type', 'description', 'order'],
      where: {
        ...(type && { type }),
        isPublished
      },
      order: [['order', 'ASC']],
      limit,
      offset
    })
  })
}
```

#### äº‹åŠ¡å¤„ç†
```typescript
// âœ… å¥½çš„äº‹åŠ¡å¤„ç†
async function createAgentWithValidation(agentData: AgentConfigCreationAttributes) {
  const transaction = await sequelize.transaction()
  
  try {
    // éªŒè¯æ•°æ®
    const validationResult = await validateAgentData(agentData)
    if (!validationResult.isValid) {
      throw new ValidationError(validationResult.errors)
    }
    
    // åˆ›å»ºæ™ºèƒ½ä½“
    const agent = await AgentConfig.create(agentData, { transaction })
    
    // åˆ›å»ºç›¸å…³é…ç½®
    await createAgentSettings(agent.id, agentData.settings, { transaction })
    
    await transaction.commit()
    return agent
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}
```

### 2. é”™è¯¯å¤„ç†è§„èŒƒ

#### ç»Ÿä¸€é”™è¯¯å¤„ç†
```typescript
// lib/errors/database-errors.ts
export class DatabaseError extends Error {
  constructor(
    message: string,
    public code: string,
    public originalError?: Error
  ) {
    super(message)
    this.name = 'DatabaseError'
  }
}

export class ValidationError extends DatabaseError {
  constructor(public errors: string[]) {
    super('æ•°æ®éªŒè¯å¤±è´¥', 'VALIDATION_ERROR')
    this.name = 'ValidationError'
  }
}

export class ConnectionError extends DatabaseError {
  constructor(message: string, originalError?: Error) {
    super(message, 'CONNECTION_ERROR', originalError)
    this.name = 'ConnectionError'
  }
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
export function handleDatabaseError(error: unknown): never {
  if (error instanceof ValidationError) {
    throw error
  }
  
  if (error instanceof DatabaseError) {
    throw error
  }
  
  // Sequelizeé”™è¯¯å¤„ç†
  if (error instanceof Error && 'parent' in error) {
    const sequelizeError = error as any
    if (sequelizeError.parent?.code === '23505') {
      throw new DatabaseError('æ•°æ®å·²å­˜åœ¨', 'DUPLICATE_ENTRY', error)
    }
    if (sequelizeError.parent?.code === '23503') {
      throw new DatabaseError('å¤–é”®çº¦æŸé”™è¯¯', 'FOREIGN_KEY_CONSTRAINT', error)
    }
  }
  
  throw new DatabaseError('æ•°æ®åº“æ“ä½œå¤±è´¥', 'UNKNOWN_ERROR', error)
}
```

### 3. æ•°æ®è¿ç§»è§„èŒƒ

#### è¿ç§»æ–‡ä»¶ç»“æ„
```typescript
// migrations/20241212000000-optimize-agent-config-indexes.js
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // æ·»åŠ ç´¢å¼•
    await queryInterface.addIndex('agent_config', ['type', 'is_published'], {
      name: 'idx_agent_config_type_published'
    })
    
    await queryInterface.addIndex('agent_config', ['order'], {
      name: 'idx_agent_config_order'
    })
  },

  down: async (queryInterface, Sequelize) => {
    // åˆ é™¤ç´¢å¼•
    await queryInterface.removeIndex('agent_config', 'idx_agent_config_type_published')
    await queryInterface.removeIndex('agent_config', 'idx_agent_config_order')
  }
};
```

## ğŸ› ï¸ å·¥å…·é…ç½®

### 1. æ•°æ®åº“è¿æ¥æ£€æŸ¥è„šæœ¬
```typescript
// scripts/check-db.ts
import DatabaseManager from '../lib/db/connection'

async function checkDatabaseConnection() {
  try {
    await DatabaseManager.connect()
    
    // æµ‹è¯•æŸ¥è¯¢
    const result = await DatabaseManager.getInstance().$queryRaw`SELECT 1 as test`
    console.log('âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸')
    
    // æ£€æŸ¥è¡¨ç»“æ„
    const tables = await DatabaseManager.getInstance().$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `
    console.log('ğŸ“Š æ•°æ®åº“è¡¨:', tables)
    
  } catch (error) {
    console.error('âŒ æ•°æ®åº“è¿æ¥å¤±è´¥:', error)
    process.exit(1)
  } finally {
    await DatabaseManager.disconnect()
  }
}

checkDatabaseConnection()
```

### 2. æ€§èƒ½æµ‹è¯•è„šæœ¬
```typescript
// scripts/benchmark-db.ts
import DatabaseManager from '../lib/db/connection'
import { performance } from 'perf_hooks'

async function benchmarkQueries() {
  const iterations = 1000
  const times: number[] = []
  
  for (let i = 0; i < iterations; i++) {
    const start = performance.now()
    
    await DatabaseManager.getInstance().agentConfig.findMany({
      where: { isPublished: true },
      take: 10
    })
    
    const end = performance.now()
    times.push(end - start)
  }
  
  const avgTime = times.reduce((a, b) => a + b, 0) / times.length
  const maxTime = Math.max(...times)
  const minTime = Math.min(...times)
  
  console.log(`ğŸ“Š æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡ (${iterations}æ¬¡):`)
  console.log(`å¹³å‡æ—¶é—´: ${avgTime.toFixed(2)}ms`)
  console.log(`æœ€å¤§æ—¶é—´: ${maxTime.toFixed(2)}ms`)
  console.log(`æœ€å°æ—¶é—´: ${minTime.toFixed(2)}ms`)
}

benchmarkQueries()
```

## ğŸ“Š è´¨é‡æŒ‡æ ‡

### æ•°æ®åº“æ€§èƒ½æŒ‡æ ‡
- **æŸ¥è¯¢å“åº”æ—¶é—´**: ç›®æ ‡ < 50ms
- **è¿æ¥æ± ä½¿ç”¨ç‡**: ç›®æ ‡ < 80%
- **ç¼“å­˜å‘½ä¸­ç‡**: ç›®æ ‡ > 90%
- **é”™è¯¯ç‡**: ç›®æ ‡ < 0.1%

### ç›‘æ§å‘½ä»¤
```bash
# æ•°æ®åº“è¿æ¥æ£€æŸ¥
npm run db:check

# æ€§èƒ½æµ‹è¯•
npm run db:benchmark

# ç´¢å¼•åˆ†æ
npm run db:analyze

# ç¼“å­˜çŠ¶æ€æ£€æŸ¥
npm run cache:status
```

## âš ï¸ é‡è¦æé†’

1. **ä¸¥æ ¼éµå¾ª**: æ‰€æœ‰æ•°æ®åº“æ“ä½œå¿…é¡»éµå¾ªæœ¬è§„èŒƒ
2. **æ€§èƒ½ä¼˜å…ˆ**: æŸ¥è¯¢ä¼˜åŒ–å’Œç´¢å¼•è®¾è®¡æ˜¯é‡ç‚¹
3. **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„æ•°æ®åº“ç›‘æ§ä½“ç³»
4. **å¤‡ä»½æ¢å¤**: å®šæœŸå¤‡ä»½ï¼Œæµ‹è¯•æ¢å¤æµç¨‹
5. **å®‰å…¨é˜²æŠ¤**: é˜²æ­¢SQLæ³¨å…¥ï¼Œä¿æŠ¤æ•æ„Ÿæ•°æ®

**è®°ä½: æ•°æ®åº“æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œå¿…é¡»ç¡®ä¿é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€é«˜å®‰å…¨ã€‚**# æ•°æ®åº“å¤„ç†è§„èŒƒ

## ğŸ¯ æ•°æ®åº“æ¶æ„åŸåˆ™

### 1. æŠ€æœ¯æ ˆé€‰æ‹©
- **ORM**: Sequelize (å½“å‰) / Prisma (æ¨èå‡çº§)
- **æ•°æ®åº“**: PostgreSQL (ä¼ä¸šçº§)
- **è¿æ¥æ± **: å·²é…ç½®ï¼Œéœ€è¦ä¼˜åŒ–
- **ç¼“å­˜**: Redis (å·²é…ç½®ï¼Œéœ€è¦å……åˆ†åˆ©ç”¨)

### 2. æ•°æ®åº“è®¾è®¡åŸåˆ™
- **è§„èŒƒåŒ–**: éµå¾ªç¬¬ä¸‰èŒƒå¼ï¼Œé¿å…æ•°æ®å†—ä½™
- **æ€§èƒ½ä¼˜å…ˆ**: åˆç†ç´¢å¼•è®¾è®¡ï¼ŒæŸ¥è¯¢ä¼˜åŒ–
- **æ•°æ®å®Œæ•´æ€§**: å¤–é”®çº¦æŸï¼Œæ•°æ®ç±»å‹ä¸¥æ ¼
- **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•å’Œå‚ç›´æ‰©å±•

## ğŸ“Š å½“å‰æ•°æ®åº“æ–¹æ¡ˆåˆ†æ

### ç°æœ‰é…ç½®è¯„ä¼°
```typescript
// lib/db/sequelize.ts - å½“å‰é…ç½®
const sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, {
  host: DB_HOST,
  port: DB_PORT,
  dialect: 'postgres',
  pool: {
    max: 10,        // æœ€å¤§è¿æ¥æ•°
    min: 0,         // æœ€å°è¿æ¥æ•°
    acquire: 30000, // è·å–è¿æ¥è¶…æ—¶
    idle: 10000,    // ç©ºé—²è¿æ¥è¶…æ—¶
  },
  define: {
    freezeTableName: true,
    underscored: true,
  },
});
```

**é—®é¢˜è¯†åˆ«**:
- âŒ è¿æ¥æ± é…ç½®åä¿å®ˆ
- âŒ ç¼ºå°‘æŸ¥è¯¢æ€§èƒ½ç›‘æ§
- âŒ ç¼ºå°‘è¿æ¥æ± ç›‘æ§
- âŒ ç¼ºå°‘é‡è¯•æœºåˆ¶

## ğŸš€ ä¼˜åŒ–æ–¹æ¡ˆ

### 1. è¿æ¥æ± ä¼˜åŒ–

#### æ¨èé…ç½®
```typescript
const sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, {
  host: DB_HOST,
  port: DB_PORT,
  dialect: 'postgres',
  dialectModule: pg,
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  
  // ä¼˜åŒ–è¿æ¥æ± é…ç½®
  pool: {
    max: 20,        // å¢åŠ æœ€å¤§è¿æ¥æ•°
    min: 5,         // å¢åŠ æœ€å°è¿æ¥æ•°
    acquire: 30000, // è·å–è¿æ¥è¶…æ—¶
    idle: 10000,    // ç©ºé—²è¿æ¥è¶…æ—¶
    evict: 1000,    // æ¸…ç†é—´éš”
    handleDisconnects: true, // å¤„ç†æ–­å¼€è¿æ¥
  },
  
  // æ·»åŠ é‡è¯•æœºåˆ¶
  retry: {
    max: 3,         // æœ€å¤§é‡è¯•æ¬¡æ•°
    timeout: 60000, // é‡è¯•è¶…æ—¶
    match: [
      /ETIMEDOUT/,
      /EHOSTUNREACH/,
      /ECONNRESET/,
      /ECONNREFUSED/,
      /ETIMEDOUT/,
      /ESOCKETTIMEDOUT/,
      /EHOSTUNREACH/,
      /EPIPE/,
      /EAI_AGAIN/,
      /SequelizeConnectionError/,
      /SequelizeConnectionRefusedError/,
      /SequelizeHostNotFoundError/,
      /SequelizeHostNotReachableError/,
      /SequelizeInvalidConnectionError/,
      /SequelizeConnectionTimedOutError/
    ]
  },
  
  // æ€§èƒ½ç›‘æ§
  benchmark: true,
  
  // æŸ¥è¯¢ä¼˜åŒ–
  define: {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: false, // è½¯åˆ é™¤
  },
  
  // æŸ¥è¯¢ä¼˜åŒ–é…ç½®
  query: {
    raw: false,
    nest: true,
    plain: false
  }
});
```

### 2. ä½¿ç”¨æˆç†Ÿçš„æ•°æ®åº“è§£å†³æ–¹æ¡ˆ

#### æ¨èå‡çº§åˆ° Prisma
```typescript
// ä¼˜åŠ¿å¯¹æ¯”
// Sequelize: æˆç†Ÿç¨³å®šï¼Œä½†ç±»å‹æ”¯æŒæœ‰é™
// Prisma: ç±»å‹å®‰å…¨ï¼Œè‡ªåŠ¨ç”Ÿæˆå®¢æˆ·ç«¯ï¼Œæ›´å¥½çš„å¼€å‘ä½“éªŒ

// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AgentConfig {
  id            Int      @id @default(autoincrement())
  name          String
  type          String
  apiKey        String
  appId         String
  apiUrl        String?
  systemPrompt  String
  temperature   Float    @default(0.7)
  maxTokens     Int      @default(2000)
  isPublished   Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("agent_config")
}
```

#### æ•°æ®åº“è¿æ¥ç®¡ç†
```typescript
// lib/db/connection.ts
import { PrismaClient } from '@prisma/client'

class DatabaseManager {
  private static instance: PrismaClient
  private static isConnected = false

  static getInstance(): PrismaClient {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new PrismaClient({
        log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],
        errorFormat: 'pretty',
      })
    }
    return DatabaseManager.instance
  }

  static async connect(): Promise<void> {
    if (!DatabaseManager.isConnected) {
      try {
        await DatabaseManager.getInstance().$connect()
        DatabaseManager.isConnected = true
        console.log('æ•°æ®åº“è¿æ¥æˆåŠŸ')
      } catch (error) {
        console.error('æ•°æ®åº“è¿æ¥å¤±è´¥:', error)
        throw error
      }
    }
  }

  static async disconnect(): Promise<void> {
    if (DatabaseManager.isConnected) {
      await DatabaseManager.getInstance().$disconnect()
      DatabaseManager.isConnected = false
      console.log('æ•°æ®åº“è¿æ¥å·²æ–­å¼€')
    }
  }
}

export default DatabaseManager
```

### 3. æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

#### ç´¢å¼•ä¼˜åŒ–
```sql
-- ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
CREATE INDEX idx_agent_config_type ON agent_config(type);
CREATE INDEX idx_agent_config_published ON agent_config(is_published);
CREATE INDEX idx_chat_history_session_id ON chat_history(session_id);
CREATE INDEX idx_chat_history_created_at ON chat_history(created_at);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_agent_config_type_published ON agent_config(type, is_published);
```

#### æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹
```typescript
// âŒ ä¸å¥½çš„æŸ¥è¯¢
const agents = await AgentConfig.findAll({
  where: { isPublished: true },
  order: [['order', 'ASC']]
})

// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨ç´¢å¼•ï¼Œé™åˆ¶å­—æ®µ
const agents = await AgentConfig.findAll({
  attributes: ['id', 'name', 'type', 'description', 'order'],
  where: { isPublished: true },
  order: [['order', 'ASC']],
  limit: 100
})

// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨åŸå§‹SQLä¼˜åŒ–
const agents = await sequelize.query(`
  SELECT id, name, type, description, "order"
  FROM agent_config 
  WHERE is_published = true 
  ORDER BY "order" ASC 
  LIMIT 100
`, {
  type: QueryTypes.SELECT,
  raw: true
})
```

### 4. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### Redisç¼“å­˜é…ç½®
```typescript
// lib/cache/redis.ts
import Redis from 'ioredis'

class CacheManager {
  private redis: Redis

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || '0'),
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
    })

    this.redis.on('error', (err) => {
      console.error('Redisè¿æ¥é”™è¯¯:', err)
    })
  }

  // æ™ºèƒ½ä½“é…ç½®ç¼“å­˜
  async getAgentConfigs(): Promise<AgentConfig[] | null> {
    const cached = await this.redis.get('agent_configs')
    return cached ? JSON.parse(cached) : null
  }

  async setAgentConfigs(configs: AgentConfig[], ttl = 300): Promise<void> {
    await this.redis.setex('agent_configs', ttl, JSON.stringify(configs))
  }

  // ç”¨æˆ·ä¼šè¯ç¼“å­˜
  async getSession(sessionId: string): Promise<any> {
    const cached = await this.redis.get(`session:${sessionId}`)
    return cached ? JSON.parse(cached) : null
  }

  async setSession(sessionId: string, data: any, ttl = 3600): Promise<void> {
    await this.redis.setex(`session:${sessionId}`, ttl, JSON.stringify(data))
  }

  // ç¼“å­˜å¤±æ•ˆ
  async invalidateAgentConfigs(): Promise<void> {
    await this.redis.del('agent_configs')
  }
}

export default new CacheManager()
```

### 5. æ•°æ®åº“ç›‘æ§

#### æ€§èƒ½ç›‘æ§
```typescript
// lib/monitoring/database.ts
export class DatabaseMonitor {
  private static queryTimes: number[] = []
  private static errorCount = 0

  static async monitorQuery<T>(
    queryName: string,
    queryFn: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now()
    
    try {
      const result = await queryFn()
      const duration = Date.now() - startTime
      
      // è®°å½•æŸ¥è¯¢æ—¶é—´
      this.queryTimes.push(duration)
      
      // å¦‚æœæŸ¥è¯¢æ—¶é—´è¶…è¿‡1ç§’ï¼Œè®°å½•è­¦å‘Š
      if (duration > 1000) {
        console.warn(`æ…¢æŸ¥è¯¢è­¦å‘Š: ${queryName} è€—æ—¶ ${duration}ms`)
      }
      
      return result
    } catch (error) {
      this.errorCount++
      console.error(`æ•°æ®åº“æŸ¥è¯¢é”™è¯¯ [${queryName}]:`, error)
      throw error
    }
  }

  static getStats() {
    return {
      averageQueryTime: this.queryTimes.reduce((a, b) => a + b, 0) / this.queryTimes.length,
      maxQueryTime: Math.max(...this.queryTimes),
      errorCount: this.errorCount,
      totalQueries: this.queryTimes.length
    }
  }
}
```

## ğŸ“‹ æ•°æ®åº“æ“ä½œè§„èŒƒ

### 1. æŸ¥è¯¢è§„èŒƒ

#### åŸºç¡€æŸ¥è¯¢
```typescript
// âœ… å¥½çš„æŸ¥è¯¢ - ä½¿ç”¨ç±»å‹å®‰å…¨
interface GetAgentConfigsParams {
  type?: string
  isPublished?: boolean
  limit?: number
  offset?: number
}

async function getAgentConfigs(params: GetAgentConfigsParams = {}) {
  const { type, isPublished = true, limit = 100, offset = 0 } = params
  
  return await DatabaseMonitor.monitorQuery('getAgentConfigs', async () => {
    return await AgentConfig.findAll({
      attributes: ['id', 'name', 'type', 'description', 'order'],
      where: {
        ...(type && { type }),
        isPublished
      },
      order: [['order', 'ASC']],
      limit,
      offset
    })
  })
}
```

#### äº‹åŠ¡å¤„ç†
```typescript
// âœ… å¥½çš„äº‹åŠ¡å¤„ç†
async function createAgentWithValidation(agentData: AgentConfigCreationAttributes) {
  const transaction = await sequelize.transaction()
  
  try {
    // éªŒè¯æ•°æ®
    const validationResult = await validateAgentData(agentData)
    if (!validationResult.isValid) {
      throw new ValidationError(validationResult.errors)
    }
    
    // åˆ›å»ºæ™ºèƒ½ä½“
    const agent = await AgentConfig.create(agentData, { transaction })
    
    // åˆ›å»ºç›¸å…³é…ç½®
    await createAgentSettings(agent.id, agentData.settings, { transaction })
    
    await transaction.commit()
    return agent
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}
```

### 2. é”™è¯¯å¤„ç†è§„èŒƒ

#### ç»Ÿä¸€é”™è¯¯å¤„ç†
```typescript
// lib/errors/database-errors.ts
export class DatabaseError extends Error {
  constructor(
    message: string,
    public code: string,
    public originalError?: Error
  ) {
    super(message)
    this.name = 'DatabaseError'
  }
}

export class ValidationError extends DatabaseError {
  constructor(public errors: string[]) {
    super('æ•°æ®éªŒè¯å¤±è´¥', 'VALIDATION_ERROR')
    this.name = 'ValidationError'
  }
}

export class ConnectionError extends DatabaseError {
  constructor(message: string, originalError?: Error) {
    super(message, 'CONNECTION_ERROR', originalError)
    this.name = 'ConnectionError'
  }
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
export function handleDatabaseError(error: unknown): never {
  if (error instanceof ValidationError) {
    throw error
  }
  
  if (error instanceof DatabaseError) {
    throw error
  }
  
  // Sequelizeé”™è¯¯å¤„ç†
  if (error instanceof Error && 'parent' in error) {
    const sequelizeError = error as any
    if (sequelizeError.parent?.code === '23505') {
      throw new DatabaseError('æ•°æ®å·²å­˜åœ¨', 'DUPLICATE_ENTRY', error)
    }
    if (sequelizeError.parent?.code === '23503') {
      throw new DatabaseError('å¤–é”®çº¦æŸé”™è¯¯', 'FOREIGN_KEY_CONSTRAINT', error)
    }
  }
  
  throw new DatabaseError('æ•°æ®åº“æ“ä½œå¤±è´¥', 'UNKNOWN_ERROR', error)
}
```

### 3. æ•°æ®è¿ç§»è§„èŒƒ

#### è¿ç§»æ–‡ä»¶ç»“æ„
```typescript
// migrations/20241212000000-optimize-agent-config-indexes.js
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // æ·»åŠ ç´¢å¼•
    await queryInterface.addIndex('agent_config', ['type', 'is_published'], {
      name: 'idx_agent_config_type_published'
    })
    
    await queryInterface.addIndex('agent_config', ['order'], {
      name: 'idx_agent_config_order'
    })
  },

  down: async (queryInterface, Sequelize) => {
    // åˆ é™¤ç´¢å¼•
    await queryInterface.removeIndex('agent_config', 'idx_agent_config_type_published')
    await queryInterface.removeIndex('agent_config', 'idx_agent_config_order')
  }
};
```

## ğŸ› ï¸ å·¥å…·é…ç½®

### 1. æ•°æ®åº“è¿æ¥æ£€æŸ¥è„šæœ¬
```typescript
// scripts/check-db.ts
import DatabaseManager from '../lib/db/connection'

async function checkDatabaseConnection() {
  try {
    await DatabaseManager.connect()
    
    // æµ‹è¯•æŸ¥è¯¢
    const result = await DatabaseManager.getInstance().$queryRaw`SELECT 1 as test`
    console.log('âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸')
    
    // æ£€æŸ¥è¡¨ç»“æ„
    const tables = await DatabaseManager.getInstance().$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `
    console.log('ğŸ“Š æ•°æ®åº“è¡¨:', tables)
    
  } catch (error) {
    console.error('âŒ æ•°æ®åº“è¿æ¥å¤±è´¥:', error)
    process.exit(1)
  } finally {
    await DatabaseManager.disconnect()
  }
}

checkDatabaseConnection()
```

### 2. æ€§èƒ½æµ‹è¯•è„šæœ¬
```typescript
// scripts/benchmark-db.ts
import DatabaseManager from '../lib/db/connection'
import { performance } from 'perf_hooks'

async function benchmarkQueries() {
  const iterations = 1000
  const times: number[] = []
  
  for (let i = 0; i < iterations; i++) {
    const start = performance.now()
    
    await DatabaseManager.getInstance().agentConfig.findMany({
      where: { isPublished: true },
      take: 10
    })
    
    const end = performance.now()
    times.push(end - start)
  }
  
  const avgTime = times.reduce((a, b) => a + b, 0) / times.length
  const maxTime = Math.max(...times)
  const minTime = Math.min(...times)
  
  console.log(`ğŸ“Š æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡ (${iterations}æ¬¡):`)
  console.log(`å¹³å‡æ—¶é—´: ${avgTime.toFixed(2)}ms`)
  console.log(`æœ€å¤§æ—¶é—´: ${maxTime.toFixed(2)}ms`)
  console.log(`æœ€å°æ—¶é—´: ${minTime.toFixed(2)}ms`)
}

benchmarkQueries()
```

## ğŸ“Š è´¨é‡æŒ‡æ ‡

### æ•°æ®åº“æ€§èƒ½æŒ‡æ ‡
- **æŸ¥è¯¢å“åº”æ—¶é—´**: ç›®æ ‡ < 50ms
- **è¿æ¥æ± ä½¿ç”¨ç‡**: ç›®æ ‡ < 80%
- **ç¼“å­˜å‘½ä¸­ç‡**: ç›®æ ‡ > 90%
- **é”™è¯¯ç‡**: ç›®æ ‡ < 0.1%

### ç›‘æ§å‘½ä»¤
```bash
# æ•°æ®åº“è¿æ¥æ£€æŸ¥
npm run db:check

# æ€§èƒ½æµ‹è¯•
npm run db:benchmark

# ç´¢å¼•åˆ†æ
npm run db:analyze

# ç¼“å­˜çŠ¶æ€æ£€æŸ¥
npm run cache:status
```

## âš ï¸ é‡è¦æé†’

1. **ä¸¥æ ¼éµå¾ª**: æ‰€æœ‰æ•°æ®åº“æ“ä½œå¿…é¡»éµå¾ªæœ¬è§„èŒƒ
2. **æ€§èƒ½ä¼˜å…ˆ**: æŸ¥è¯¢ä¼˜åŒ–å’Œç´¢å¼•è®¾è®¡æ˜¯é‡ç‚¹
3. **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„æ•°æ®åº“ç›‘æ§ä½“ç³»
4. **å¤‡ä»½æ¢å¤**: å®šæœŸå¤‡ä»½ï¼Œæµ‹è¯•æ¢å¤æµç¨‹
5. **å®‰å…¨é˜²æŠ¤**: é˜²æ­¢SQLæ³¨å…¥ï¼Œä¿æŠ¤æ•æ„Ÿæ•°æ®

**è®°ä½: æ•°æ®åº“æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œå¿…é¡»ç¡®ä¿é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€é«˜å®‰å…¨ã€‚**
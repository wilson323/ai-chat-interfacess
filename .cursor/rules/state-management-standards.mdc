---
alwaysApply: true
---

# 状态管理标准规范

## 🎯 状态管理原则

### 1. 统一状态管理
- **单一数据源**: 使用 Zustand 作为全局状态管理
- **状态分层**: 全局状态、组件状态、服务状态分离
- **状态同步**: 自动同步服务端状态和客户端状态
- **状态持久化**: 关键状态持久化到 localStorage

### 2. 性能优化
- **精确订阅**: 使用选择器精确订阅需要的状态片段
- **状态分片**: 按功能模块拆分状态，避免大对象
- **状态缓存**: 使用 TanStack Query 缓存服务端状态
- **状态更新优化**: 使用 Immer 确保不可变更新

### 3. 类型安全
- **完整类型定义**: 所有状态都有完整的 TypeScript 类型
- **类型约束**: 使用类型约束确保状态更新安全
- **类型推导**: 利用 TypeScript 类型推导减少重复代码

## 🏗️ 状态管理架构

### 1. 状态分层
```typescript
// 全局状态 - Zustand
const useAppStore = create<AppState>()

// 服务状态 - TanStack Query
const { data: agents } = useQuery(['agents'], fetchAgents)

// 组件状态 - useState
const [localState, setLocalState] = useState()
```

### 2. 状态选择器
```typescript
// 精确订阅，避免不必要的重渲染
const user = useAppStore((state) => state.user)
const userActions = useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// 使用预定义选择器
const { user, userActions } = useStableSelectors()
```

### 3. 状态同步
```typescript
// 自动同步服务端状态
const useAgentSync = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  useEffect(() => {
    if (agents) {
      setAgents(agents)
    }
  }, [agents, setAgents])
}
```

## 📦 状态管理工具

### 1. Zustand Store
```typescript
// lib/store/appStore.ts
export const useAppStore = create<AppState>()(
  persist(
    immer((set, get) => ({
      // 状态定义
      user: { id: null, name: null },
      
      // 操作方法
      setUser: (user) => set((state) => {
        Object.assign(state.user, user)
      })
    })),
    {
      name: 'app-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
```

### 2. 状态选择器
```typescript
// lib/store/selectors.ts
export const useUser = () => useAppStore((state) => state.user)
export const useUserActions = () => useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))
```

### 3. 服务状态管理
```typescript
// lib/hooks/useAgents.ts
export const useAgents = () => {
  return useQuery({
    queryKey: ['agents'],
    queryFn: fetchAgents,
    staleTime: 5 * 60 * 1000
  })
}
```

## 🔧 状态管理规范

### 1. 状态定义规范
```typescript
/**
 * 应用状态接口
 * 包含所有全局状态和操作方法
 */
interface AppState {
  // 状态定义
  user: UserState
  agents: AgentState
  ui: UIState
  
  // 操作方法
  setUser: (user: Partial<UserState>) => void
  setAgents: (agents: Agent[]) => void
}
```

### 2. 状态更新规范
```typescript
// ✅ 正确的状态更新 - 使用 Immer
setUser: (user) => set((state) => {
  Object.assign(state.user, user)
})

// ❌ 错误的状态更新 - 直接修改
setUser: (user) => set((state) => {
  state.user = user // 错误：直接修改状态
})
```

### 3. 状态订阅规范
```typescript
// ✅ 正确的状态订阅 - 精确订阅
const user = useAppStore((state) => state.user)
const userActions = useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// ❌ 错误的状态订阅 - 订阅整个状态
const state = useAppStore() // 错误：订阅整个状态
```

### 4. 状态同步规范
```typescript
// ✅ 正确的状态同步 - 使用 useEffect
const useAgentSync = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  useEffect(() => {
    if (agents) {
      setAgents(agents)
    }
  }, [agents, setAgents])
}

// ❌ 错误的状态同步 - 在组件中直接调用
const MyComponent = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  // 错误：在组件中直接调用
  if (agents) {
    setAgents(agents)
  }
}
```

## 📊 性能优化策略

### 1. 状态选择器优化
```typescript
// 使用选择器避免不必要的重渲染
const useUser = () => useAppStore((state) => state.user)
const useUserActions = () => useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// 使用稳定的选择器
const useStableSelectors = () => {
  const user = useUser()
  const userActions = useUserActions()
  
  return { user, userActions }
}
```

### 2. 状态分片优化
```typescript
// 按功能模块拆分状态
const useAgentState = () => useAppStore((state) => state.agents)
const useUIState = () => useAppStore((state) => state.ui)
const useChatState = () => useAppStore((state) => state.chat)
```

### 3. 状态缓存优化
```typescript
// 使用 TanStack Query 缓存服务端状态
const { data: agents, isLoading } = useQuery({
  queryKey: ['agents'],
  queryFn: fetchAgents,
  staleTime: 5 * 60 * 1000, // 5分钟内数据被认为是新鲜的
  cacheTime: 10 * 60 * 1000 // 10分钟后清理缓存
})
```

## 🧪 测试规范

### 1. 状态测试
```typescript
// __tests__/store/appStore.test.ts
describe('AppStore', () => {
  it('应该正确设置用户信息', () => {
    const { result } = renderHook(() => useAppStore())
    
    act(() => {
      result.current.setUser({ id: '1', name: 'Test User' })
    })
    
    expect(result.current.user.id).toBe('1')
    expect(result.current.user.name).toBe('Test User')
  })
})
```

### 2. 选择器测试
```typescript
// __tests__/store/selectors.test.ts
describe('Selectors', () => {
  it('应该选择用户状态', () => {
    const { result } = renderHook(() => useUser())
    expect(result.current).toBeDefined()
  })
})
```

### 3. 性能测试
```typescript
// __tests__/store/performance.test.ts
describe('Performance', () => {
  it('应该支持大量状态更新', () => {
    const { result } = renderHook(() => useAppStore())
    const startTime = performance.now()
    
    act(() => {
      for (let i = 0; i < 1000; i++) {
        result.current.setGlobalVariable(`key${i}`, `value${i}`)
      }
    })
    
    const endTime = performance.now()
    expect(endTime - startTime).toBeLessThan(100)
  })
})
```

## 📋 开发检查清单

### 状态定义检查
- [ ] 状态接口完整定义
- [ ] 状态类型安全
- [ ] 状态默认值设置
- [ ] 状态验证规则

### 状态更新检查
- [ ] 使用 Immer 确保不可变更新
- [ ] 状态更新逻辑正确
- [ ] 状态更新性能优化
- [ ] 状态更新错误处理

### 状态订阅检查
- [ ] 使用精确选择器
- [ ] 避免订阅整个状态
- [ ] 状态订阅性能优化
- [ ] 状态订阅清理

### 状态同步检查
- [ ] 服务端状态同步
- [ ] 本地状态持久化
- [ ] 状态同步错误处理
- [ ] 状态同步性能优化

## ⚠️ 注意事项

1. **状态更新**: 始终使用 Immer 确保不可变更新
2. **状态订阅**: 使用精确选择器避免不必要的重渲染
3. **状态同步**: 使用 useEffect 进行状态同步
4. **状态测试**: 确保状态管理逻辑有完整的测试覆盖
5. **性能监控**: 持续监控状态更新性能

## 🎯 最佳实践

### 1. 状态设计
- 按功能模块设计状态结构
- 使用扁平化状态结构
- 避免深层嵌套状态

### 2. 状态更新
- 使用 Immer 确保不可变更新
- 批量更新相关状态
- 避免频繁的状态更新

### 3. 状态订阅
- 使用精确选择器
- 避免订阅整个状态
- 使用稳定的选择器引用

### 4. 状态同步
- 使用 TanStack Query 管理服务端状态
- 使用 useEffect 进行状态同步
- 处理状态同步错误

**记住: 好的状态管理是应用性能的基础，统一的状态管理确保应用的可维护性和可扩展性。**# 状态管理标准规范

## 🎯 状态管理原则

### 1. 统一状态管理
- **单一数据源**: 使用 Zustand 作为全局状态管理
- **状态分层**: 全局状态、组件状态、服务状态分离
- **状态同步**: 自动同步服务端状态和客户端状态
- **状态持久化**: 关键状态持久化到 localStorage

### 2. 性能优化
- **精确订阅**: 使用选择器精确订阅需要的状态片段
- **状态分片**: 按功能模块拆分状态，避免大对象
- **状态缓存**: 使用 TanStack Query 缓存服务端状态
- **状态更新优化**: 使用 Immer 确保不可变更新

### 3. 类型安全
- **完整类型定义**: 所有状态都有完整的 TypeScript 类型
- **类型约束**: 使用类型约束确保状态更新安全
- **类型推导**: 利用 TypeScript 类型推导减少重复代码

## 🏗️ 状态管理架构

### 1. 状态分层
```typescript
// 全局状态 - Zustand
const useAppStore = create<AppState>()

// 服务状态 - TanStack Query
const { data: agents } = useQuery(['agents'], fetchAgents)

// 组件状态 - useState
const [localState, setLocalState] = useState()
```

### 2. 状态选择器
```typescript
// 精确订阅，避免不必要的重渲染
const user = useAppStore((state) => state.user)
const userActions = useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// 使用预定义选择器
const { user, userActions } = useStableSelectors()
```

### 3. 状态同步
```typescript
// 自动同步服务端状态
const useAgentSync = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  useEffect(() => {
    if (agents) {
      setAgents(agents)
    }
  }, [agents, setAgents])
}
```

## 📦 状态管理工具

### 1. Zustand Store
```typescript
// lib/store/appStore.ts
export const useAppStore = create<AppState>()(
  persist(
    immer((set, get) => ({
      // 状态定义
      user: { id: null, name: null },
      
      // 操作方法
      setUser: (user) => set((state) => {
        Object.assign(state.user, user)
      })
    })),
    {
      name: 'app-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
```

### 2. 状态选择器
```typescript
// lib/store/selectors.ts
export const useUser = () => useAppStore((state) => state.user)
export const useUserActions = () => useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))
```

### 3. 服务状态管理
```typescript
// lib/hooks/useAgents.ts
export const useAgents = () => {
  return useQuery({
    queryKey: ['agents'],
    queryFn: fetchAgents,
    staleTime: 5 * 60 * 1000
  })
}
```

## 🔧 状态管理规范

### 1. 状态定义规范
```typescript
/**
 * 应用状态接口
 * 包含所有全局状态和操作方法
 */
interface AppState {
  // 状态定义
  user: UserState
  agents: AgentState
  ui: UIState
  
  // 操作方法
  setUser: (user: Partial<UserState>) => void
  setAgents: (agents: Agent[]) => void
}
```

### 2. 状态更新规范
```typescript
// ✅ 正确的状态更新 - 使用 Immer
setUser: (user) => set((state) => {
  Object.assign(state.user, user)
})

// ❌ 错误的状态更新 - 直接修改
setUser: (user) => set((state) => {
  state.user = user // 错误：直接修改状态
})
```

### 3. 状态订阅规范
```typescript
// ✅ 正确的状态订阅 - 精确订阅
const user = useAppStore((state) => state.user)
const userActions = useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// ❌ 错误的状态订阅 - 订阅整个状态
const state = useAppStore() // 错误：订阅整个状态
```

### 4. 状态同步规范
```typescript
// ✅ 正确的状态同步 - 使用 useEffect
const useAgentSync = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  useEffect(() => {
    if (agents) {
      setAgents(agents)
    }
  }, [agents, setAgents])
}

// ❌ 错误的状态同步 - 在组件中直接调用
const MyComponent = () => {
  const { data: agents } = useAgents()
  const setAgents = useAppStore((state) => state.setAgents)
  
  // 错误：在组件中直接调用
  if (agents) {
    setAgents(agents)
  }
}
```

## 📊 性能优化策略

### 1. 状态选择器优化
```typescript
// 使用选择器避免不必要的重渲染
const useUser = () => useAppStore((state) => state.user)
const useUserActions = () => useAppStore((state) => ({
  setUser: state.setUser,
  clearUser: state.clearUser
}))

// 使用稳定的选择器
const useStableSelectors = () => {
  const user = useUser()
  const userActions = useUserActions()
  
  return { user, userActions }
}
```

### 2. 状态分片优化
```typescript
// 按功能模块拆分状态
const useAgentState = () => useAppStore((state) => state.agents)
const useUIState = () => useAppStore((state) => state.ui)
const useChatState = () => useAppStore((state) => state.chat)
```

### 3. 状态缓存优化
```typescript
// 使用 TanStack Query 缓存服务端状态
const { data: agents, isLoading } = useQuery({
  queryKey: ['agents'],
  queryFn: fetchAgents,
  staleTime: 5 * 60 * 1000, // 5分钟内数据被认为是新鲜的
  cacheTime: 10 * 60 * 1000 // 10分钟后清理缓存
})
```

## 🧪 测试规范

### 1. 状态测试
```typescript
// __tests__/store/appStore.test.ts
describe('AppStore', () => {
  it('应该正确设置用户信息', () => {
    const { result } = renderHook(() => useAppStore())
    
    act(() => {
      result.current.setUser({ id: '1', name: 'Test User' })
    })
    
    expect(result.current.user.id).toBe('1')
    expect(result.current.user.name).toBe('Test User')
  })
})
```

### 2. 选择器测试
```typescript
// __tests__/store/selectors.test.ts
describe('Selectors', () => {
  it('应该选择用户状态', () => {
    const { result } = renderHook(() => useUser())
    expect(result.current).toBeDefined()
  })
})
```

### 3. 性能测试
```typescript
// __tests__/store/performance.test.ts
describe('Performance', () => {
  it('应该支持大量状态更新', () => {
    const { result } = renderHook(() => useAppStore())
    const startTime = performance.now()
    
    act(() => {
      for (let i = 0; i < 1000; i++) {
        result.current.setGlobalVariable(`key${i}`, `value${i}`)
      }
    })
    
    const endTime = performance.now()
    expect(endTime - startTime).toBeLessThan(100)
  })
})
```

## 📋 开发检查清单

### 状态定义检查
- [ ] 状态接口完整定义
- [ ] 状态类型安全
- [ ] 状态默认值设置
- [ ] 状态验证规则

### 状态更新检查
- [ ] 使用 Immer 确保不可变更新
- [ ] 状态更新逻辑正确
- [ ] 状态更新性能优化
- [ ] 状态更新错误处理

### 状态订阅检查
- [ ] 使用精确选择器
- [ ] 避免订阅整个状态
- [ ] 状态订阅性能优化
- [ ] 状态订阅清理

### 状态同步检查
- [ ] 服务端状态同步
- [ ] 本地状态持久化
- [ ] 状态同步错误处理
- [ ] 状态同步性能优化

## ⚠️ 注意事项

1. **状态更新**: 始终使用 Immer 确保不可变更新
2. **状态订阅**: 使用精确选择器避免不必要的重渲染
3. **状态同步**: 使用 useEffect 进行状态同步
4. **状态测试**: 确保状态管理逻辑有完整的测试覆盖
5. **性能监控**: 持续监控状态更新性能

## 🎯 最佳实践

### 1. 状态设计
- 按功能模块设计状态结构
- 使用扁平化状态结构
- 避免深层嵌套状态

### 2. 状态更新
- 使用 Immer 确保不可变更新
- 批量更新相关状态
- 避免频繁的状态更新

### 3. 状态订阅
- 使用精确选择器
- 避免订阅整个状态
- 使用稳定的选择器引用

### 4. 状态同步
- 使用 TanStack Query 管理服务端状态
- 使用 useEffect 进行状态同步
- 处理状态同步错误

**记住: 好的状态管理是应用性能的基础，统一的状态管理确保应用的可维护性和可扩展性。**
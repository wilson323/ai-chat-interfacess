/**
 * Á≥ªÁªüÊû∂ÊûÑÂ∏àÊô∫ËÉΩ‰Ωì
 * System Architect Agent - Project structure and architecture analysis
 */

import { promises as fs } from 'fs';
import * as path from 'path';

export interface ProjectStructure {
  directories: number;
  files: number;
  mainTechnologies: string[];
  architecturePattern: string;
  folderTree: FolderNode;
}

export interface FolderNode {
  name: string;
  type: 'directory' | 'file';
  path: string;
  children?: FolderNode[];
  size?: number;
  extension?: string;
}

export interface DependencyAnalysis {
  total: number;
  production: number;
  development: number;
  outdated: number;
  securityIssues: number;
  dependencyTree: DependencyNode[];
}

export interface DependencyNode {
  name: string;
  version: string;
  type: 'production' | 'development';
  licenses: string[];
  size: number;
  dependencies: string[];
  securityAdvisories?: SecurityAdvisory[];
}

export interface SecurityAdvisory {
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  patchedIn?: string;
}

export interface ModuleAnalysis {
  separationOfConcerns: boolean;
  reusability: 'low' | 'medium' | 'high';
  maintainability: 'poor' | 'fair' | 'good' | 'excellent';
  coupling: 'tight' | 'loose';
  cohesion: 'low' | 'medium' | 'high';
  circularDependencies: string[];
}

export class SystemArchitectAgent {
  private projectRoot: string;
  private analysisResults: any = {};

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  async analyzeArchitecture(): Promise<{
    projectStructure: ProjectStructure;
    dependencies: DependencyAnalysis;
    moduleOrganization: ModuleAnalysis;
    recommendations: string[];
  }> {
    console.log('üèóÔ∏è Á≥ªÁªüÊû∂ÊûÑÂ∏àÂºÄÂßãÂàÜÊûêÈ°πÁõÆÊû∂ÊûÑ...');

    const [projectStructure, dependencies, moduleOrganization] = await Promise.all([
      this.analyzeProjectStructure(),
      this.analyzeDependencies(),
      this.analyzeModuleOrganization()
    ]);

    const recommendations = this.generateArchitectureRecommendations(
      projectStructure,
      dependencies,
      moduleOrganization
    );

    return {
      projectStructure,
      dependencies,
      moduleOrganization,
      recommendations
    };
  }

  private async analyzeProjectStructure(): Promise<ProjectStructure> {
    console.log('üìÅ ÂàÜÊûêÈ°πÁõÆÁªìÊûÑ...');

    const folderTree = await this.buildFolderTree(this.projectRoot);
    const stats = this.calculateStructureStats(folderTree);

    const mainTechnologies = await this.identifyMainTechnologies();
    const architecturePattern = await this.detectArchitecturePattern();

    return {
      directories: stats.directories,
      files: stats.files,
      mainTechnologies,
      architecturePattern,
      folderTree
    };
  }

  private async buildFolderTree(dirPath: string, maxDepth: number = 3, currentDepth: number = 0): Promise<FolderNode> {
    const stats = await fs.stat(dirPath);
    const name = path.basename(dirPath);
    const node: FolderNode = {
      name,
      type: stats.isDirectory() ? 'directory' : 'file',
      path: path.relative(this.projectRoot, dirPath)
    };

    if (stats.isFile()) {
      node.size = stats.size;
      node.extension = path.extname(name);
    }

    if (stats.isDirectory() && currentDepth < maxDepth) {
      try {
        const entries = await fs.readdir(dirPath);
        const children: FolderNode[] = [];

        for (const entry of entries) {
          const fullPath = path.join(dirPath, entry);

          // Ë∑≥Ëøánode_modulesÂíåÂÖ∂‰ªñÂøΩÁï•ÁõÆÂΩï
          if (this.shouldIgnorePath(entry)) continue;

          try {
            const childNode = await this.buildFolderTree(fullPath, maxDepth, currentDepth + 1);
            children.push(childNode);
          } catch (error) {
            console.warn(`Ë∑≥ËøáÊó†Ê≥ïËÆøÈóÆÁöÑË∑ØÂæÑ: ${fullPath}`);
          }
        }

        node.children = children.sort((a, b) => {
          if (a.type !== b.type) {
            return a.type === 'directory' ? -1 : 1;
          }
          return a.name.localeCompare(b.name);
        });
      } catch (error) {
        console.warn(`Êó†Ê≥ïËØªÂèñÁõÆÂΩï: ${dirPath}`);
      }
    }

    return node;
  }

  private shouldIgnorePath(name: string): boolean {
    const ignorePatterns = [
      'node_modules',
      '.git',
      'dist',
      'build',
      '.next',
      'coverage',
      '.cache',
      'temp',
      'tmp',
      '*.log',
      '.DS_Store'
    ];

    return ignorePatterns.some(pattern =>
      name.includes(pattern) || name.startsWith('.')
    );
  }

  private calculateStructureStats(tree: FolderNode): { directories: number; files: number } {
    let directories = 0;
    let files = 0;

    function countNodes(node: FolderNode) {
      if (node.type === 'directory') {
        directories++;
        node.children?.forEach(countNodes);
      } else {
        files++;
      }
    }

    countNodes(tree);
    return { directories, files };
  }

  private async identifyMainTechnologies(): Promise<string[]> {
    const technologies: string[] = [];

    try {
      const packageJsonPath = path.join(this.projectRoot, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));

      const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };

      if (deps.next) technologies.push('Next.js');
      if (deps.react) technologies.push('React');
      if (deps.typescript) technologies.push('TypeScript');
      if (deps.tailwindcss) technologies.push('Tailwind CSS');
      if (deps.shadcn) technologies.push('shadcn/ui');
      if (deps.antd) technologies.push('Ant Design');
      if (deps.postgres || deps.pg) technologies.push('PostgreSQL');
      if (deps.redis) technologies.push('Redis');
      if (deps.docker) technologies.push('Docker');
      if (deps.jest) technologies.push('Jest');

      return technologies;
    } catch (error) {
      console.warn('Êó†Ê≥ïËØªÂèñpackage.json:', error);
      return ['Unknown'];
    }
  }

  private async detectArchitecturePattern(): Promise<string> {
    const appPath = path.join(this.projectRoot, 'app');
    const pagesPath = path.join(this.projectRoot, 'pages');

    try {
      const appExists = await this.pathExists(appPath);
      const pagesExists = await this.pathExists(pagesPath);

      if (appExists) return 'App Router + API Routes';
      if (pagesExists) return 'Pages Router + API Routes';
      return 'Custom Architecture';
    } catch (error) {
      return 'Unknown';
    }
  }

  private async analyzeDependencies(): Promise<DependencyAnalysis> {
    console.log('üì¶ ÂàÜÊûêÈ°πÁõÆ‰æùËµñ...');

    try {
      const packageJsonPath = path.join(this.projectRoot, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));

      const dependencies = Object.entries(packageJson.dependencies || {});
      const devDependencies = Object.entries(packageJson.devDependencies || {});

      const dependencyNodes: DependencyNode[] = [];

      // ÂàÜÊûêÁîü‰∫ß‰æùËµñ
      for (const [name, version] of dependencies) {
        const node = await this.analyzeDependency(name, version as string, 'production');
        dependencyNodes.push(node);
      }

      // ÂàÜÊûêÂºÄÂèë‰æùËµñ
      for (const [name, version] of devDependencies) {
        const node = await this.analyzeDependency(name, version as string, 'development');
        dependencyNodes.push(node);
      }

      return {
        total: dependencies.length + devDependencies.length,
        production: dependencies.length,
        development: devDependencies.length,
        outdated: dependencyNodes.filter(d => this.isOutdated(d.version)).length,
        securityIssues: dependencyNodes.reduce((sum, d) => sum + (d.securityAdvisories?.length || 0), 0),
        dependencyTree: dependencyNodes
      };
    } catch (error) {
      console.error('‰æùËµñÂàÜÊûêÂ§±Ë¥•:', error);
      return {
        total: 0,
        production: 0,
        development: 0,
        outdated: 0,
        securityIssues: 0,
        dependencyTree: []
      };
    }
  }

  private async analyzeDependency(name: string, version: string, type: 'production' | 'development'): Promise<DependencyNode> {
    try {
      const packagePath = path.join(this.projectRoot, 'node_modules', name, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packagePath, 'utf-8'));

      const licenses = this.extractLicenses(packageJson);
      const size = await this.calculatePackageSize(name);
      const dependencies = Object.keys(packageJson.dependencies || {});

      return {
        name,
        version,
        type,
        licenses,
        size,
        dependencies,
        securityAdvisories: [] // ËøôÈáåÂèØ‰ª•ÈõÜÊàêÂÆâÂÖ®Êï∞ÊçÆÂ∫ìÊü•ËØ¢
      };
    } catch (error) {
      return {
        name,
        version,
        type,
        licenses: ['Unknown'],
        size: 0,
        dependencies: [],
        securityAdvisories: []
      };
    }
  }

  private extractLicenses(packageJson: any): string[] {
    const license = packageJson.license || packageJson.licenses;
    if (Array.isArray(license)) {
      return license.map(l => typeof l === 'string' ? l : l.type);
    }
    return [typeof license === 'string' ? license : 'Unknown'];
  }

  private async calculatePackageSize(name: string): Promise<number> {
    try {
      const packagePath = path.join(this.projectRoot, 'node_modules', name);
      return await this.calculateDirectorySize(packagePath);
    } catch (error) {
      return 0;
    }
  }

  private async calculateDirectorySize(dirPath: string): Promise<number> {
    let totalSize = 0;

    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);

        if (entry.isDirectory() && entry.name !== 'node_modules') {
          totalSize += await this.calculateDirectorySize(fullPath);
        } else if (entry.isFile()) {
          const stats = await fs.stat(fullPath);
          totalSize += stats.size;
        }
      }
    } catch (error) {
      // ÂøΩÁï•Êó†Ê≥ïËÆøÈóÆÁöÑÊñá‰ª∂
    }

    return totalSize;
  }

  private isOutdated(version: string): boolean {
    // ÁÆÄÂåñÁöÑÁâàÊú¨Ê£ÄÊü•ÈÄªËæë
    return version.includes('^0.') || version.includes('~0.');
  }

  private async analyzeModuleOrganization(): Promise<ModuleAnalysis> {
    console.log('üîß ÂàÜÊûêÊ®°ÂùóÁªÑÁªáÁªìÊûÑ...');

    const separationOfConcerns = await this.checkSeparationOfConcerns();
    const circularDeps = await this.detectCircularDependencies();

    return {
      separationOfConcerns,
      reusability: 'high',
      maintainability: 'good',
      coupling: 'loose',
      cohesion: 'high',
      circularDependencies: circularDeps
    };
  }

  private async checkSeparationOfConcerns(): Promise<boolean> {
    const expectedStructure = [
      'app',
      'components',
      'lib',
      'types',
      'hooks',
      'tests',
      'scripts'
    ];

    try {
      const entries = await fs.readdir(this.projectRoot);
      return expectedStructure.every(dir => entries.includes(dir));
    } catch (error) {
      return false;
    }
  }

  private async detectCircularDependencies(): Promise<string[]> {
    // ÁÆÄÂåñÁöÑÂæ™ÁéØ‰æùËµñÊ£ÄÊµã
    // Âú®ÂÆûÈôÖÂÆûÁé∞‰∏≠ÔºåÂèØ‰ª•‰ΩøÁî®Êõ¥Â§çÊùÇÁöÑÈùôÊÄÅÂàÜÊûêÂ∑•ÂÖ∑
    return [];
  }

  private generateArchitectureRecommendations(
    structure: ProjectStructure,
    dependencies: DependencyAnalysis,
    modules: ModuleAnalysis
  ): string[] {
    const recommendations: string[] = [];

    if (dependencies.outdated > 0) {
      recommendations.push(`Êõ¥Êñ∞ ${dependencies.outdated} ‰∏™ËøáÊó∂‰æùËµñ`);
    }

    if (dependencies.securityIssues > 0) {
      recommendations.push(`‰øÆÂ§ç ${dependencies.securityIssues} ‰∏™‰æùËµñÂÆâÂÖ®ÈóÆÈ¢ò`);
    }

    if (!modules.separationOfConcerns) {
      recommendations.push('ÊîπÂñÑÂÖ≥Ê≥®ÁÇπÂàÜÁ¶ªÔºå‰ºòÂåñÁõÆÂΩïÁªìÊûÑ');
    }

    if (modules.circularDependencies.length > 0) {
      recommendations.push('Ê∂àÈô§Âæ™ÁéØ‰æùËµñÔºåÊèêÈ´ò‰ª£Á†ÅÂèØÁª¥Êä§ÊÄß');
    }

    if (structure.mainTechnologies.length < 3) {
      recommendations.push('ÊäÄÊúØÊ†àÁõ∏ÂØπÁÆÄÂçïÔºåÂèØ‰ª•ËÄÉËôëÂºïÂÖ•Êõ¥Â§öÁé∞‰ª£ÂåñÂ∑•ÂÖ∑');
    }

    recommendations.push('ÂÆöÊúüÊâßË°åÊû∂ÊûÑÂÆ°Êü•Ôºå‰øùÊåÅ‰ª£Á†ÅË¥®Èáè');

    return recommendations;
  }

  private async pathExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async generateReport(): Promise<string> {
    const analysis = await this.analyzeArchitecture();

    return `
# üèóÔ∏è Á≥ªÁªüÊû∂ÊûÑÂàÜÊûêÊä•Âëä

## üìÅ È°πÁõÆÁªìÊûÑÂàÜÊûê
- **ÁõÆÂΩïÊï∞**: ${analysis.projectStructure.directories}
- **Êñá‰ª∂Êï∞**: ${analysis.projectStructure.files}
- **‰∏ªË¶ÅÊäÄÊúØ**: ${analysis.projectStructure.mainTechnologies.join(', ')}
- **Êû∂ÊûÑÊ®°Âºè**: ${analysis.projectStructure.architecturePattern}

## üì¶ ‰æùËµñÂàÜÊûê
- **ÊÄª‰æùËµñÊï∞**: ${analysis.dependencies.total}
- **Áîü‰∫ß‰æùËµñ**: ${analysis.dependencies.production}
- **ÂºÄÂèë‰æùËµñ**: ${analysis.dependencies.development}
- **ËøáÊó∂‰æùËµñ**: ${analysis.dependencies.outdated}
- **ÂÆâÂÖ®ÈóÆÈ¢ò**: ${analysis.dependencies.securityIssues}

## üîß Ê®°ÂùóÁªÑÁªá
- **ÂÖ≥Ê≥®ÁÇπÂàÜÁ¶ª**: ${analysis.moduleOrganization.separationOfConcerns ? '‚úÖ' : '‚ùå'}
- **ÂèØÂ§çÁî®ÊÄß**: ${analysis.moduleOrganization.reusability}
- **ÂèØÁª¥Êä§ÊÄß**: ${analysis.moduleOrganization.maintainability}
- **ËÄ¶ÂêàÂ∫¶**: ${analysis.moduleOrganization.coupling}
- **ÂÜÖËÅöÊÄß**: ${analysis.moduleOrganization.cohesion}

## üí° ÊîπËøõÂª∫ËÆÆ
${analysis.recommendations.map(rec => `- ${rec}`).join('\n')}
`;
  }
}
# 部署流程规范

## 📋 概述

本文档定义了 NeuroGlass AI Chat Interface 项目的部署流程，包括开发环境、测试环境、生产环境的部署规范和最佳实践。

---

## 🌍 环境定义

### 1. 环境分类

- **开发环境 (Development)**: 本地开发环境
- **测试环境 (Testing)**: 功能测试和集成测试环境
- **预发布环境 (Staging)**: 生产环境镜像，用于最终验证
- **生产环境 (Production)**: 正式生产环境

### 2. 环境配置

#### 开发环境

```bash
# .env.development
NODE_ENV=development
PORT=3000
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/dev_db
REDIS_URL=redis://localhost:6379
NEXT_TELEMETRY_DISABLED=1
```

#### 测试环境

```bash
# .env.test
NODE_ENV=test
PORT=3001
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db
REDIS_URL=redis://localhost:6379
NEXT_TELEMETRY_DISABLED=1
```

#### 生产环境

```bash
# .env.production
NODE_ENV=production
PORT=3009
DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@db:5432/agent_config
REDIS_URL=redis://redis:6379
NEXT_TELEMETRY_DISABLED=1
DOCKER_CONTAINER=true
```

---

## 🚀 部署策略

### 1. 蓝绿部署 (Blue-Green Deployment)

#### 部署流程

```mermaid
graph TD
    A[当前生产环境 Blue] --> B[部署新版本到 Green]
    B --> C[测试验证 Green环境]
    C --> D[切换流量到 Green]
    D --> E[监控 Green环境]
    E --> F[保留 Blue环境备用]
```

#### 实施步骤

```yaml
blue_green_deployment:
  preparation:
    - 准备Green环境
    - 部署新版本到Green
    - 配置负载均衡器

  testing:
    - 健康检查
    - 功能测试
    - 性能测试
    - 安全扫描

  cutover:
    - 修改DNS指向
    - 更新负载均衡器
    - 监控切换过程

  cleanup:
    - 保留Blue环境24小时
    - 清理旧版本资源
    - 更新文档
```

### 2. 滚动部署 (Rolling Deployment)

#### Kubernetes配置

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neuroglass-app
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  template:
    spec:
      containers:
        - name: app
          image: neuroglass/app:latest
          ports:
            - containerPort: 3009
          readinessProbe:
            httpGet:
              path: /api/health
              port: 3009
            initialDelaySeconds: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /api/health
              port: 3009
            initialDelaySeconds: 60
            periodSeconds: 30
```

### 3. 金丝雀部署 (Canary Deployment)

#### 部署策略

```yaml
canary_deployment:
  phases:
    phase1:
      name: '5%流量测试'
      percentage: 5
      duration: '30分钟'
      metrics:
        - error_rate
        - response_time
        - cpu_usage

    phase2:
      name: '25%流量测试'
      percentage: 25
      duration: '2小时'
      metrics:
        - error_rate
        - response_time
        - business_metrics

    phase3:
      name: '100%流量'
      percentage: 100
      duration: '持续'
      metrics:
        - all_metrics
```

---

## 🔧 部署工具

### 1. Docker配置

#### Dockerfile (多阶段构建)

```dockerfile
# 构建阶段
FROM node:18-alpine AS builder
WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产阶段
FROM node:18-alpine AS runner
WORKDIR /app

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 复制构建产物
COPY --from=builder --chown=nextjs:nodejs /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# 设置环境变量
ENV NODE_ENV=production
ENV PORT=3009
ENV NEXT_TELEMETRY_DISABLED=1

# 暴露端口
EXPOSE 3009

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3009/api/health || exit 1

# 启动应用
USER nextjs
CMD ["node", "server.js"]
```

#### docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - '3009:3009'
    environment:
      - NODE_ENV=production
      - NEXT_TELEMETRY_DISABLED=1
      - DOCKER_CONTAINER=true
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_HOST=db
      - POSTGRES_PORT=5452
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:3009/api/health']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    volumes:
      - ./uploads:/app/uploads
      - ./logs:/app/logs

  db:
    image: postgres:14-alpine
    container_name: neuroglass-postgres
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    ports:
      - '5452:5432'
    restart: unless-stopped
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}']
      interval: 30s
      timeout: 10s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: neuroglass-redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - '6379:6379'
    restart: unless-stopped
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    container_name: neuroglass-nginx
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 2. Kubernetes配置

#### ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: neuroglass-config
data:
  NODE_ENV: 'production'
  PORT: '3009'
  NEXT_TELEMETRY_DISABLED: '1'
```

#### Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: neuroglass-secrets
type: Opaque
data:
  POSTGRES_USER: cm9vdA==
  POSTGRES_PASSWORD: WktUZWNvIyMxMjM=
  JWT_SECRET: eW91ci1qd3Qtc2VjcmV0LWtleQ==
```

---

## 📋 部署流程

### 1. 开发环境部署

#### 本地开发环境设置

```bash
#!/bin/bash
# scripts/setup-dev.sh

echo "🚀 设置开发环境..."

# 检查依赖
echo "📦 检查Node.js版本..."
node --version
npm --version

# 安装依赖
echo "📥 安装依赖..."
npm install

# 设置环境变量
echo "🔧 设置环境变量..."
cp .env.example .env.development

# 启动数据库
echo "🗄️ 启动数据库..."
docker-compose up -d db redis

# 运行数据库迁移
echo "🔄 运行数据库迁移..."
npm run db:migrate

# 启动开发服务器
echo "🖥️ 启动开发服务器..."
npm run dev
```

### 2. 测试环境部署

#### 自动化测试部署

```bash
#!/bin/bash
# scripts/deploy-test.sh

set -e

echo "🧪 部署到测试环境..."

# 运行测试
echo "🧪 运行单元测试..."
npm run test:unit

echo "🧪 运行集成测试..."
npm run test:integration

echo "🧪 运行E2E测试..."
npm run test:e2e

# 构建应用
echo "🔨 构建应用..."
npm run build

# 部署到测试服务器
echo "📤 部署到测试服务器..."
scp -r .next test-server:/opt/neuroglass/
ssh test-server "cd /opt/neuroglass && npm run start"

# 运行健康检查
echo "🏥 运行健康检查..."
curl -f http://test-server:3001/api/health

echo "✅ 测试环境部署完成！"
```

### 3. 生产环境部署

#### 生产部署脚本

```bash
#!/bin/bash
# scripts/deploy-production.sh

set -e

echo "🚀 开始生产环境部署..."

# 预检查
echo "🔍 运行部署前检查..."
./scripts/pre-deploy-check.sh

# 备份当前版本
echo "💾 备份当前版本..."
./scripts/backup.sh

# 运行测试
echo "🧪 运行完整测试套件..."
npm run test:ci
npm run test:security
npm run test:performance

# 构建Docker镜像
echo "🐳 构建Docker镜像..."
docker build -t neuroglass/app:${VERSION} .

# 推送镜像到仓库
echo "📤 推送镜像到仓库..."
docker push neuroglass/app:${VERSION}

# 部署到生产环境
echo "🚀 部署到生产环境..."
kubectl set image deployment/neuroglass-app app=neuroglass/app:${VERSION}

# 等待部署完成
echo "⏳ 等待部署完成..."
kubectl rollout status deployment/neuroglass-app --timeout=600s

# 运行健康检查
echo "🏥 运行健康检查..."
./scripts/health-check.sh

# 验证部署
echo "✅ 验证部署..."
./scripts/verify-deployment.sh

echo "🎉 生产环境部署完成！"
```

---

## 🔍 部署前检查

### 1. 代码质量检查

```bash
#!/bin/bash
# scripts/pre-deploy-check.sh

echo "🔍 运行部署前检查..."

# 代码质量检查
echo "📊 检查代码质量..."
npm run check-code
if [ $? -ne 0 ]; then
    echo "❌ 代码质量检查失败"
    exit 1
fi

# 自定义代码占比检查
echo "📊 检查自定义代码占比..."
npm run check:custom-ratio
if [ $? -ne 0 ]; then
    echo "❌ 自定义代码占比过高"
    exit 1
fi

# 安全检查
echo "🔒 运行安全检查..."
npm run test:security
if [ $? -ne 0 ]; then
    echo "❌ 安全检查失败"
    exit 1
fi

# 性能检查
echo "⚡ 运行性能检查..."
npm run test:performance
if [ $? -ne 0 ]; then
    echo "❌ 性能检查失败"
    exit 1
fi

echo "✅ 所有检查通过！"
```

### 2. 环境配置检查

```bash
#!/bin/bash
# scripts/check-environment.sh

echo "🔍 检查环境配置..."

# 检查必需的环境变量
required_vars=(
    "NODE_ENV"
    "PORT"
    "DATABASE_URL"
    "REDIS_URL"
    "JWT_SECRET"
    "FASTGPT_API_KEY"
    "OPENAI_AUDIO_API_KEY"
)

for var in "${required_vars[@]}"; do
    if [ -z "${!var}" ]; then
        echo "❌ 环境变量 $var 未设置"
        exit 1
    fi
done

# 检查数据库连接
echo "🗄️ 检查数据库连接..."
npm run check-db

# 检查Redis连接
echo "🔴 检查Redis连接..."
npm run check-redis

echo "✅ 环境配置检查通过！"
```

---

## 🏥 健康检查

### 1. 应用健康检查

```typescript
// app/api/health/route.ts
import { NextResponse } from 'next/server';
import { sequelize } from '@/lib/db/sequelize';
import { redisClient } from '@/lib/redis';

export async function GET() {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || 'unknown',
    uptime: process.uptime(),
    checks: {
      database: await checkDatabase(),
      redis: await checkRedis(),
      externalApis: await checkExternalApis(),
    },
  };

  const isHealthy = Object.values(health.checks).every(
    check => check.status === 'healthy'
  );

  return NextResponse.json(health, {
    status: isHealthy ? 200 : 503,
  });
}

async function checkDatabase() {
  try {
    await sequelize.authenticate();
    await sequelize.query('SELECT 1');
    return { status: 'healthy', latency: Date.now() };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error.message,
      latency: Date.now(),
    };
  }
}

async function checkRedis() {
  try {
    await redisClient.ping();
    return { status: 'healthy', latency: Date.now() };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error.message,
      latency: Date.now(),
    };
  }
}

async function checkExternalApis() {
  const checks = {};

  // 检查FastGPT API
  try {
    const response = await fetch(process.env.FASTGPT_API_URL, {
      headers: {
        Authorization: `Bearer ${process.env.FASTGPT_API_KEY}`,
      },
    });
    checks.fastgpt = response.ok ? 'healthy' : 'unhealthy';
  } catch (error) {
    checks.fastgpt = 'unhealthy';
  }

  return checks;
}
```

### 2. 系统健康检查脚本

```bash
#!/bin/bash
# scripts/health-check.sh

echo "🏥 运行系统健康检查..."

# 检查应用服务
echo "🌐 检查应用服务..."
APP_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3009/api/health)
if [ "$APP_HEALTH" -eq 200 ]; then
    echo "✅ 应用服务正常"
else
    echo "❌ 应用服务异常 (HTTP $APP_HEALTH)"
    exit 1
fi

# 检查数据库
echo "🗄️ 检查数据库..."
DB_HEALTH=$(docker exec neuroglass-postgres pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB})
if [ $? -eq 0 ]; then
    echo "✅ 数据库正常"
else
    echo "❌ 数据库异常"
    exit 1
fi

# 检查Redis
echo "🔴 检查Redis..."
REDIS_HEALTH=$(docker exec neuroglass-redis redis-cli ping)
if [ "$REDIS_HEALTH" = "PONG" ]; then
    echo "✅ Redis正常"
else
    echo "❌ Redis异常"
    exit 1
fi

# 检查资源使用
echo "📊 检查资源使用..."
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')
MEMORY_USAGE=$(free | grep Mem | awk '{print ($3/$2) * 100.0}')

echo "CPU使用率: ${CPU_USAGE}%"
echo "内存使用率: ${MEMORY_USAGE}%"

if (( $(echo "$CPU_USAGE > 80" | bc -l) )); then
    echo "⚠️ CPU使用率过高"
fi

if (( $(echo "$MEMORY_USAGE > 80" | bc -l) )); then
    echo "⚠️ 内存使用率过高"
fi

echo "✅ 系统健康检查完成！"
```

---

## 🔄 回滚流程

### 1. 快速回滚

```bash
#!/bin/bash
# scripts/rollback.sh

set -e

VERSION=${1:-"previous"}

echo "🔄 开始回滚到版本 $VERSION..."

# 检查当前状态
echo "🔍 检查当前部署状态..."
kubectl get deployment neuroglass-app

# 回滚到指定版本
echo "🔄 回滚部署..."
kubectl rollout undo deployment/neuroglass-app --to-revision=$VERSION

# 等待回滚完成
echo "⏳ 等待回滚完成..."
kubectl rollout status deployment/neuroglass-app --timeout=600s

# 验证回滚
echo "✅ 验证回滚结果..."
./scripts/verify-deployment.sh

echo "🎉 回滚完成！"
```

### 2. 数据库回滚

```bash
#!/bin/bash
# scripts/rollback-database.sh

set -e

echo "🔄 开始数据库回滚..."

# 备份当前数据库
echo "💾 备份当前数据库..."
./scripts/backup-db.sh

# 执行回滚
echo "🔄 执行数据库回滚..."
npm run db:rollback

# 验证数据完整性
echo "✅ 验证数据完整性..."
./scripts/verify-data.sh

echo "🎉 数据库回滚完成！"
```

---

## 📊 部署监控

### 1. 部署指标监控

```typescript
// lib/monitoring/deployment-metrics.ts
export class DeploymentMetrics {
  private metrics = new Map<string, any>();

  recordDeployment(deployment: {
    version: string;
    environment: string;
    startTime: Date;
    endTime?: Date;
    status: 'success' | 'failed' | 'rolling-back';
    duration?: number;
    error?: string;
  }) {
    const key = `${deployment.environment}_${deployment.version}`;
    this.metrics.set(key, deployment);
  }

  getDeploymentHistory(environment: string, limit = 10) {
    return Array.from(this.metrics.values())
      .filter(d => d.environment === environment)
      .sort((a, b) => b.startTime.getTime() - a.startTime.getTime())
      .slice(0, limit);
  }

  getSuccessRate(environment: string) {
    const deployments = this.getDeploymentHistory(environment, 50);
    const successful = deployments.filter(d => d.status === 'success').length;
    return (successful / deployments.length) * 100;
  }

  getAverageDeploymentTime(environment: string) {
    const deployments = this.getDeploymentHistory(environment, 50).filter(
      d => d.status === 'success' && d.duration
    );

    if (deployments.length === 0) return 0;

    const totalTime = deployments.reduce((sum, d) => sum + d.duration!, 0);
    return totalTime / deployments.length;
  }
}
```

### 2. 部署通知

```typescript
// lib/notifications/deployment-notifier.ts
export class DeploymentNotifier {
  async notifySuccess(deployment: DeploymentInfo) {
    const message = `
🎉 部署成功！

环境: ${deployment.environment}
版本: ${deployment.version}
持续时间: ${deployment.duration}ms
部署时间: ${deployment.timestamp}

✅ 所有检查通过
    `;

    await this.sendNotification('success', message);
  }

  async notifyFailure(deployment: DeploymentInfo, error: string) {
    const message = `
❌ 部署失败！

环境: ${deployment.environment}
版本: ${deployment.version}
错误: ${error}
部署时间: ${deployment.timestamp}

🔄 正在启动回滚流程...
    `;

    await this.sendNotification('failure', message);
  }

  private async sendNotification(type: 'success' | 'failure', message: string) {
    // Slack通知
    await this.sendSlackNotification(message);

    // 邮件通知
    await this.sendEmailNotification(message);

    // PagerDuty通知 (仅限failure)
    if (type === 'failure') {
      await this.sendPagerDutyNotification(message);
    }
  }
}
```

---

## 📋 部署文档

### 1. 部署检查清单

```markdown
## 部署前检查清单

- [ ] 代码质量检查通过
- [ ] 测试覆盖率达标
- [ ] 安全扫描通过
- [ ] 性能测试通过
- [ ] 环境配置验证
- [ ] 数据库备份完成
- [ ] 回滚方案准备

## 部署过程检查清单

- [ ] 部署脚本执行成功
- [ ] 服务启动正常
- [ ] 健康检查通过
- [ ] 数据库迁移成功
- [ ] 配置文件正确
- [ ] 权限设置正确

## 部署后检查清单

- [ ] 应用功能正常
- [ ] 性能指标正常
- [ ] 错误日志正常
- [ ] 监控数据正常
- [ ] 用户反馈收集
- [ ] 文档更新
```

### 2. 故障恢复流程

```markdown
## 故障分类

1. **P1 - 严重故障**: 服务完全不可用
2. **P2 - 重要故障**: 核心功能不可用
3. **P3 - 一般故障**: 非核心功能异常

## 故障响应时间

- **P1**: 15分钟内响应
- **P2**: 30分钟内响应
- **P3**: 2小时内响应

## 故障恢复步骤

1. 立即通知相关人员
2. 启动故障诊断
3. 执行临时修复
4. 启动回滚流程（如需要）
5. 根因分析
6. 实施永久修复
7. 验证修复效果
```

---

**最后更新**: 2025-01-13
**版本**: v1.0.0
**维护者**: 运维团队

# åç«¯æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç›®æ ‡

### 1. æ ¸å¿ƒæŒ‡æ ‡

- **APIå“åº”æ—¶é—´**: < 500ms (95%è¯·æ±‚)
- **æ•°æ®åº“æŸ¥è¯¢æ—¶é—´**: < 100ms (95%æŸ¥è¯¢)
- **Rediså“åº”æ—¶é—´**: < 10ms (95%æ“ä½œ)
- **å¹¶å‘å¤„ç†èƒ½åŠ›**: > 1000 QPS
- **å†…å­˜ä½¿ç”¨ç‡**: < 80%
- **CPUä½¿ç”¨ç‡**: < 70%

### 2. æ€§èƒ½é¢„ç®—

- **æ•°æ®åº“è¿æ¥æ± **: æœ€å¤§20ä¸ªè¿æ¥
- **Redisè¿æ¥æ± **: æœ€å¤§50ä¸ªè¿æ¥
- **APIè¶…æ—¶**: 30ç§’
- **æ•°æ®åº“è¶…æ—¶**: 10ç§’
- **Redisè¶…æ—¶**: 5ç§’

## ğŸ—ï¸ ä¼˜åŒ–ç­–ç•¥

### 1. æ•°æ®åº“ä¼˜åŒ–

```typescript
// è¿æ¥æ± ä¼˜åŒ–
const poolConfig = {
  max: 20, // æœ€å¤§è¿æ¥æ•°
  min: 5, // æœ€å°è¿æ¥æ•°
  acquire: 30000, // è·å–è¿æ¥è¶…æ—¶
  idle: 10000, // ç©ºé—²è¿æ¥è¶…æ—¶
  evict: 1000, // æ¸…ç†é—´éš”
  handleDisconnects: true,
};

// æŸ¥è¯¢ä¼˜åŒ–
const queryConfig = {
  raw: false, // è¿”å›å¯¹è±¡è€Œéæ•°ç»„
  nest: true, // åµŒå¥—å¯¹è±¡
  plain: false, // è¿”å›æ•°ç»„
  benchmark: true, // æ€§èƒ½ç›‘æ§
};
```

### 2. Redisç¼“å­˜ä¼˜åŒ–

```typescript
// è¿æ¥æ± é…ç½®
const redisConfig = {
  host: 'localhost',
  port: 6379,
  password: '',
  db: 0,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3,
  lazyConnect: true,
  keepAlive: 30000,
  family: 4,
  connectTimeout: 10000,
  commandTimeout: 5000,
};

// ç¼“å­˜ç­–ç•¥
const cacheStrategy = {
  agents: { ttl: 300, maxSize: 1000 },
  config: { ttl: 600, maxSize: 100 },
  sessions: { ttl: 3600, maxSize: 10000 },
  api_responses: { ttl: 60, maxSize: 5000 },
};
```

### 3. APIæ€§èƒ½ä¼˜åŒ–

```typescript
// è¯·æ±‚é™æµ
const rateLimitConfig = {
  windowMs: 60000, // 1åˆ†é’Ÿ
  max: 100, // æœ€å¤§è¯·æ±‚æ•°
  standardHeaders: true,
  legacyHeaders: false,
};

// å“åº”å‹ç¼©
const compressionConfig = {
  level: 6,
  threshold: 1024,
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
};
```

## ğŸ”§ æŠ€æœ¯å®ç°

### 1. æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–

```typescript
// lib/db/connection-pool.ts
import { Sequelize } from 'sequelize';
import { appConfig } from '@/lib/config';
import { performanceMonitor } from '@/lib/performance/monitor';

class DatabaseConnectionPool {
  private sequelize: Sequelize;
  private stats = {
    totalConnections: 0,
    activeConnections: 0,
    idleConnections: 0,
    waitingRequests: 0,
  };

  constructor() {
    this.sequelize = new Sequelize(
      appConfig.database.database,
      appConfig.database.username,
      appConfig.database.password,
      {
        host: appConfig.database.host,
        port: appConfig.database.port,
        dialect: 'postgres',
        logging: false,

        // è¿æ¥æ± é…ç½®
        pool: {
          max: appConfig.database.pool.max,
          min: appConfig.database.pool.min,
          acquire: appConfig.database.pool.acquire,
          idle: appConfig.database.pool.idle,
          evict: 1000,
          handleDisconnects: true,
        },

        // é‡è¯•æœºåˆ¶
        retry: {
          max: 3,
          timeout: 60000,
          match: [
            /ETIMEDOUT/,
            /EHOSTUNREACH/,
            /ECONNRESET/,
            /ECONNREFUSED/,
            /SequelizeConnectionError/,
          ],
        },

        // æ€§èƒ½ç›‘æ§
        benchmark: true,

        // æŸ¥è¯¢ä¼˜åŒ–
        define: {
          freezeTableName: true,
          underscored: true,
          timestamps: true,
          paranoid: false,
        },

        // æŸ¥è¯¢é…ç½®
        query: {
          raw: false,
          nest: true,
          plain: false,
        },
      }
    );

    this.setupEventListeners();
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
   */
  private setupEventListeners(): void {
    this.sequelize.connectionManager.on('connect', connection => {
      this.stats.totalConnections++;
      this.stats.activeConnections++;
      console.log('Database connection established');
    });

    this.sequelize.connectionManager.on('disconnect', connection => {
      this.stats.activeConnections--;
      console.log('Database connection closed');
    });

    this.sequelize.connectionManager.on('acquire', connection => {
      this.stats.activeConnections++;
      this.stats.idleConnections--;
    });

    this.sequelize.connectionManager.on('release', connection => {
      this.stats.activeConnections--;
      this.stats.idleConnections++;
    });
  }

  /**
   * è·å–è¿æ¥æ± å®ä¾‹
   */
  getInstance(): Sequelize {
    return this.sequelize;
  }

  /**
   * è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return {
      ...this.stats,
      pool: this.sequelize.connectionManager.pool,
    };
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.sequelize.authenticate();
      return true;
    } catch (error) {
      console.error('Database health check failed:', error);
      return false;
    }
  }

  /**
   * å…³é—­è¿æ¥æ± 
   */
  async close(): Promise<void> {
    await this.sequelize.close();
  }
}

export const dbPool = new DatabaseConnectionPool();
```

### 2. Redisè¿æ¥æ± ä¼˜åŒ–

```typescript
// lib/db/redis-pool.ts
import { createClient, RedisClientType } from 'redis';
import { appConfig } from '@/lib/config';

class RedisConnectionPool {
  private client: RedisClientType;
  private stats = {
    totalConnections: 0,
    activeConnections: 0,
    commandsExecuted: 0,
    errors: 0,
  };

  constructor() {
    this.client = createClient({
      url: `redis://${appConfig.redis.host}:${appConfig.redis.port}`,
      password: appConfig.redis.password,
      database: appConfig.redis.db,

      socket: {
        reconnectStrategy: retries => Math.min(retries * 50, 2000),
        connectTimeout: 10000,
        commandTimeout: 5000,
        keepAlive: 30000,
      },

      // è¿æ¥æ± é…ç½®
      commandsQueueMaxLength: 1000,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
    });

    this.setupEventListeners();
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
   */
  private setupEventListeners(): void {
    this.client.on('connect', () => {
      this.stats.totalConnections++;
      this.stats.activeConnections++;
      console.log('Redis connection established');
    });

    this.client.on('disconnect', () => {
      this.stats.activeConnections--;
      console.log('Redis connection closed');
    });

    this.client.on('error', error => {
      this.stats.errors++;
      console.error('Redis error:', error);
    });

    this.client.on('ready', () => {
      console.log('Redis client ready');
    });
  }

  /**
   * è¿æ¥Redis
   */
  async connect(): Promise<void> {
    if (!this.client.isOpen) {
      await this.client.connect();
    }
  }

  /**
   * æ–­å¼€è¿æ¥
   */
  async disconnect(): Promise<void> {
    if (this.client.isOpen) {
      await this.client.disconnect();
    }
  }

  /**
   * è·å–å®¢æˆ·ç«¯å®ä¾‹
   */
  getClient(): RedisClientType {
    return this.client;
  }

  /**
   * æ‰§è¡Œå‘½ä»¤
   */
  async executeCommand<T>(command: () => Promise<T>): Promise<T> {
    try {
      const result = await command();
      this.stats.commandsExecuted++;
      return result;
    } catch (error) {
      this.stats.errors++;
      throw error;
    }
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return {
      ...this.stats,
      isConnected: this.client.isOpen,
    };
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.client.ping();
      return true;
    } catch (error) {
      console.error('Redis health check failed:', error);
      return false;
    }
  }
}

export const redisPool = new RedisConnectionPool();
```

### 3. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

```typescript
// lib/cache/redis-cache.ts
import { redisPool } from '@/lib/db/redis-pool';
import { performanceMonitor } from '@/lib/performance/monitor';

interface CacheOptions {
  ttl?: number;
  tags?: string[];
  compress?: boolean;
}

class RedisCacheManager {
  private defaultTTL = 300; // 5åˆ†é’Ÿ
  private compressionThreshold = 1024; // 1KB

  /**
   * è®¾ç½®ç¼“å­˜
   */
  async set<T>(
    key: string,
    value: T,
    options: CacheOptions = {}
  ): Promise<void> {
    const startTime = Date.now();

    try {
      const { ttl = this.defaultTTL, tags = [], compress = false } = options;

      let serializedValue: string;

      if (
        compress &&
        JSON.stringify(value).length > this.compressionThreshold
      ) {
        // å‹ç¼©å¤§å¯¹è±¡
        serializedValue = await this.compress(JSON.stringify(value));
      } else {
        serializedValue = JSON.stringify(value);
      }

      await redisPool.executeCommand(async () => {
        const pipeline = redisPool.getClient().multi();

        // è®¾ç½®ä¸»é”®
        pipeline.setex(key, ttl, serializedValue);

        // è®¾ç½®æ ‡ç­¾
        if (tags.length > 0) {
          tags.forEach(tag => {
            pipeline.sadd(`tag:${tag}`, key);
            pipeline.expire(`tag:${tag}`, ttl);
          });
        }

        await pipeline.exec();
      });

      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric('cache_set_duration', duration);
    } catch (error) {
      console.error('Failed to set cache:', error);
      throw error;
    }
  }

  /**
   * è·å–ç¼“å­˜
   */
  async get<T>(key: string): Promise<T | null> {
    const startTime = Date.now();

    try {
      const result = await redisPool.executeCommand(async () => {
        return await redisPool.getClient().get(key);
      });

      if (!result) {
        return null;
      }

      // æ£€æŸ¥æ˜¯å¦å‹ç¼©
      let parsedValue: T;
      try {
        parsedValue = JSON.parse(result);
      } catch (error) {
        // å°è¯•è§£å‹ç¼©
        parsedValue = JSON.parse(await this.decompress(result));
      }

      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric('cache_get_duration', duration);

      return parsedValue;
    } catch (error) {
      console.error('Failed to get cache:', error);
      return null;
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜
   */
  async delete(key: string): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        await redisPool.getClient().del(key);
      });
    } catch (error) {
      console.error('Failed to delete cache:', error);
      throw error;
    }
  }

  /**
   * æŒ‰æ ‡ç­¾åˆ é™¤ç¼“å­˜
   */
  async deleteByTag(tag: string): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        const keys = await redisPool.getClient().smembers(`tag:${tag}`);
        if (keys.length > 0) {
          await redisPool.getClient().del(keys);
        }
        await redisPool.getClient().del(`tag:${tag}`);
      });
    } catch (error) {
      console.error('Failed to delete cache by tag:', error);
      throw error;
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  async clear(): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        await redisPool.getClient().flushdb();
      });
    } catch (error) {
      console.error('Failed to clear cache:', error);
      throw error;
    }
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡
   */
  async getStats() {
    try {
      const info = await redisPool.executeCommand(async () => {
        return await redisPool.getClient().info('memory');
      });

      return {
        memory: this.parseRedisInfo(info),
        pool: redisPool.getStats(),
      };
    } catch (error) {
      console.error('Failed to get cache stats:', error);
      return null;
    }
  }

  /**
   * å‹ç¼©æ•°æ®
   */
  private async compress(data: string): Promise<string> {
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨zlibæˆ–å…¶ä»–å‹ç¼©åº“
    // ç®€åŒ–å®ç°ï¼Œå®é™…é¡¹ç›®ä¸­åº”è¯¥ä½¿ç”¨çœŸæ­£çš„å‹ç¼©
    return Buffer.from(data).toString('base64');
  }

  /**
   * è§£å‹ç¼©æ•°æ®
   */
  private async decompress(data: string): Promise<string> {
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨zlibæˆ–å…¶ä»–å‹ç¼©åº“
    // ç®€åŒ–å®ç°ï¼Œå®é™…é¡¹ç›®ä¸­åº”è¯¥ä½¿ç”¨çœŸæ­£çš„è§£å‹ç¼©
    return Buffer.from(data, 'base64').toString();
  }

  /**
   * è§£æRedisä¿¡æ¯
   */
  private parseRedisInfo(info: string): any {
    const lines = info.split('\r\n');
    const result: any = {};

    lines.forEach(line => {
      if (line.includes(':')) {
        const [key, value] = line.split(':');
        result[key] = isNaN(Number(value)) ? value : Number(value);
      }
    });

    return result;
  }
}

export const redisCache = new RedisCacheManager();
```

### 4. APIæ€§èƒ½ç›‘æ§

```typescript
// lib/monitoring/api-performance.ts
import { NextRequest, NextResponse } from 'next/server';
import { performanceMonitor } from '@/lib/performance/monitor';

interface APIMetrics {
  endpoint: string;
  method: string;
  duration: number;
  statusCode: number;
  timestamp: number;
  userAgent: string;
  ip: string;
}

class APIPerformanceMonitor {
  private metrics: APIMetrics[] = [];
  private maxMetrics = 1000;

  /**
   * è®°å½•APIæ€§èƒ½æŒ‡æ ‡
   */
  recordAPIMetrics(
    endpoint: string,
    method: string,
    duration: number,
    statusCode: number,
    request: NextRequest
  ): void {
    const metric: APIMetrics = {
      endpoint,
      method,
      duration,
      statusCode,
      timestamp: Date.now(),
      userAgent: request.headers.get('user-agent') || 'unknown',
      ip: this.getClientIP(request),
    };

    this.metrics.push(metric);

    // ä¿æŒæŒ‡æ ‡æ•°é‡åœ¨é™åˆ¶å†…
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }

    // è®°å½•åˆ°æ€§èƒ½ç›‘æ§å™¨
    performanceMonitor.recordMetric('api_duration', duration);
    performanceMonitor.recordMetric(`api_${endpoint}_duration`, duration);
  }

  /**
   * è·å–APIæ€§èƒ½ç»Ÿè®¡
   */
  getAPIStats(): {
    totalRequests: number;
    averageDuration: number;
    slowestEndpoints: Array<{ endpoint: string; duration: number }>;
    errorRate: number;
    requestsPerMinute: number;
  } {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;

    const recentMetrics = this.metrics.filter(m => m.timestamp > oneMinuteAgo);
    const totalDuration = this.metrics.reduce((sum, m) => sum + m.duration, 0);
    const errorCount = this.metrics.filter(m => m.statusCode >= 400).length;

    // æœ€æ…¢çš„ç«¯ç‚¹
    const endpointDurations = this.metrics.reduce(
      (acc, m) => {
        if (!acc[m.endpoint]) {
          acc[m.endpoint] = { total: 0, count: 0 };
        }
        acc[m.endpoint].total += m.duration;
        acc[m.endpoint].count += 1;
        return acc;
      },
      {} as Record<string, { total: number; count: number }>
    );

    const slowestEndpoints = Object.entries(endpointDurations)
      .map(([endpoint, stats]) => ({
        endpoint,
        duration: stats.total / stats.count,
      }))
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 10);

    return {
      totalRequests: this.metrics.length,
      averageDuration:
        this.metrics.length > 0 ? totalDuration / this.metrics.length : 0,
      slowestEndpoints,
      errorRate: this.metrics.length > 0 ? errorCount / this.metrics.length : 0,
      requestsPerMinute: recentMetrics.length,
    };
  }

  /**
   * è·å–å®¢æˆ·ç«¯IP
   */
  private getClientIP(request: NextRequest): string {
    const forwarded = request.headers.get('x-forwarded-for');
    const realIP = request.headers.get('x-real-ip');

    if (forwarded) {
      return forwarded.split(',')[0].trim();
    }

    if (realIP) {
      return realIP;
    }

    return 'unknown';
  }

  /**
   * æ¸…ç†æ—§æŒ‡æ ‡
   */
  cleanup(): void {
    const oneHourAgo = Date.now() - 3600000;
    this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo);
  }
}

export const apiPerformanceMonitor = new APIPerformanceMonitor();

/**
 * APIæ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
 */
export function withAPIPerformanceMonitoring(handler: Function) {
  return async (request: NextRequest) => {
    const startTime = Date.now();
    const url = new URL(request.url);
    const endpoint = url.pathname;
    const method = request.method;

    try {
      const response = await handler(request);
      const duration = Date.now() - startTime;

      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      apiPerformanceMonitor.recordAPIMetrics(
        endpoint,
        method,
        duration,
        response.status,
        request
      );

      return response;
    } catch (error) {
      const duration = Date.now() - startTime;

      // è®°å½•é”™è¯¯æ€§èƒ½æŒ‡æ ‡
      apiPerformanceMonitor.recordAPIMetrics(
        endpoint,
        method,
        duration,
        500,
        request
      );

      throw error;
    }
  };
}
```

### 5. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```typescript
// lib/db/query-optimizer.ts
import { Sequelize, QueryInterface } from 'sequelize';
import { dbPool } from './connection-pool';

class QueryOptimizer {
  private sequelize: Sequelize;

  constructor() {
    this.sequelize = dbPool.getInstance();
  }

  /**
   * ä¼˜åŒ–æŸ¥è¯¢
   */
  async optimizeQuery<T>(
    query: string,
    replacements?: any,
    options?: {
      useCache?: boolean;
      cacheTTL?: number;
      explain?: boolean;
    }
  ): Promise<T[]> {
    const { useCache = true, cacheTTL = 300, explain = false } = options || {};

    // ç”Ÿæˆç¼“å­˜é”®
    const cacheKey = this.generateCacheKey(query, replacements);

    // å°è¯•ä»ç¼“å­˜è·å–
    if (useCache) {
      const cached = await this.getFromCache<T>(cacheKey);
      if (cached) {
        return cached;
      }
    }

    // æ‰§è¡ŒæŸ¥è¯¢
    const startTime = Date.now();

    try {
      let result: T[];

      if (explain) {
        // æ‰§è¡ŒEXPLAINæŸ¥è¯¢
        const explainQuery = `EXPLAIN (ANALYZE, BUFFERS) ${query}`;
        const explainResult = await this.sequelize.query(explainQuery, {
          replacements,
          type: Sequelize.QueryTypes.SELECT,
        });

        console.log('Query Plan:', explainResult);
      }

      result = (await this.sequelize.query(query, {
        replacements,
        type: Sequelize.QueryTypes.SELECT,
      })) as T[];

      const duration = Date.now() - startTime;

      // è®°å½•æŸ¥è¯¢æ€§èƒ½
      this.recordQueryMetrics(query, duration, result.length);

      // ç¼“å­˜ç»“æœ
      if (useCache) {
        await this.setCache(cacheKey, result, cacheTTL);
      }

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error('Query failed:', { query, duration, error });
      throw error;
    }
  }

  /**
   * æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
   */
  async batchQuery<T>(
    queries: Array<{
      query: string;
      replacements?: any;
      key: string;
    }>
  ): Promise<Record<string, T[]>> {
    const results: Record<string, T[]> = {};

    // å¹¶è¡Œæ‰§è¡ŒæŸ¥è¯¢
    const promises = queries.map(async ({ query, replacements, key }) => {
      try {
        const result = await this.optimizeQuery<T>(query, replacements);
        return { key, result };
      } catch (error) {
        console.error(`Batch query failed for key ${key}:`, error);
        return { key, result: [] };
      }
    });

    const resolved = await Promise.all(promises);

    resolved.forEach(({ key, result }) => {
      results[key] = result;
    });

    return results;
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”®
   */
  private generateCacheKey(query: string, replacements?: any): string {
    const hash = this.hashString(query + JSON.stringify(replacements || {}));
    return `query:${hash}`;
  }

  /**
   * ä»ç¼“å­˜è·å–
   */
  private async getFromCache<T>(key: string): Promise<T[] | null> {
    try {
      const { redisCache } = await import('@/lib/cache/redis-cache');
      return await redisCache.get<T[]>(key);
    } catch (error) {
      console.warn('Failed to get from cache:', error);
      return null;
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜
   */
  private async setCache<T>(
    key: string,
    data: T[],
    ttl: number
  ): Promise<void> {
    try {
      const { redisCache } = await import('@/lib/cache/redis-cache');
      await redisCache.set(key, data, { ttl });
    } catch (error) {
      console.warn('Failed to set cache:', error);
    }
  }

  /**
   * è®°å½•æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡
   */
  private recordQueryMetrics(
    query: string,
    duration: number,
    rowCount: number
  ): void {
    // è®°å½•åˆ°æ€§èƒ½ç›‘æ§å™¨
    const { performanceMonitor } = require('@/lib/performance/monitor');
    performanceMonitor.recordMetric('db_query_duration', duration);
    performanceMonitor.recordMetric('db_query_rows', rowCount);

    // è®°å½•æ…¢æŸ¥è¯¢
    if (duration > 1000) {
      console.warn('Slow query detected:', { query, duration, rowCount });
    }
  }

  /**
   * å­—ç¬¦ä¸²å“ˆå¸Œ
   */
  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return Math.abs(hash).toString(36);
  }
}

export const queryOptimizer = new QueryOptimizer();
```

## ğŸ“Š æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

### 1. å®æ—¶æ€§èƒ½ç›‘æ§

```typescript
// app/api/admin/performance/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { dbPool } from '@/lib/db/connection-pool';
import { redisPool } from '@/lib/db/redis-pool';
import { apiPerformanceMonitor } from '@/lib/monitoring/api-performance';
import { redisCache } from '@/lib/cache/redis-cache';

export async function GET(request: NextRequest) {
  try {
    // è·å–æ•°æ®åº“æ€§èƒ½æŒ‡æ ‡
    const dbStats = dbPool.getStats();
    const dbHealth = await dbPool.healthCheck();

    // è·å–Redisæ€§èƒ½æŒ‡æ ‡
    const redisStats = redisPool.getStats();
    const redisHealth = await redisPool.healthCheck();

    // è·å–APIæ€§èƒ½æŒ‡æ ‡
    const apiStats = apiPerformanceMonitor.getAPIStats();

    // è·å–ç¼“å­˜ç»Ÿè®¡
    const cacheStats = await redisCache.getStats();

    // è·å–ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
    const systemStats = {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      cpu: process.cpuUsage(),
    };

    return NextResponse.json({
      success: true,
      data: {
        database: {
          health: dbHealth,
          stats: dbStats,
        },
        redis: {
          health: redisHealth,
          stats: redisStats,
        },
        api: apiStats,
        cache: cacheStats,
        system: systemStats,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error('Failed to get performance metrics:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to get performance metrics',
      },
      { status: 500 }
    );
  }
}
```

## ğŸ“‹ æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

### æ•°æ®åº“ä¼˜åŒ–æ£€æŸ¥

- [ ] è¿æ¥æ± é…ç½®ä¼˜åŒ–
- [ ] æŸ¥è¯¢è¯­å¥ä¼˜åŒ–
- [ ] ç´¢å¼•ä¼˜åŒ–
- [ ] æ…¢æŸ¥è¯¢ç›‘æ§
- [ ] è¿æ¥æ± ç›‘æ§

### Redisä¼˜åŒ–æ£€æŸ¥

- [ ] è¿æ¥æ± é…ç½®ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§
- [ ] å‘½ä»¤æ‰§è¡Œç›‘æ§
- [ ] é”™è¯¯å¤„ç†ä¼˜åŒ–

### APIæ€§èƒ½æ£€æŸ¥

- [ ] å“åº”æ—¶é—´ç›‘æ§
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ›
- [ ] é”™è¯¯ç‡ç›‘æ§
- [ ] èµ„æºä½¿ç”¨ç›‘æ§
- [ ] æ€§èƒ½å‘Šè­¦è®¾ç½®

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **æ¸è¿›å¼ä¼˜åŒ–**: é€æ­¥å®æ–½ä¼˜åŒ–ç­–ç•¥ï¼Œé¿å…å½±å“ç°æœ‰åŠŸèƒ½
2. **æ€§èƒ½æµ‹è¯•**: æ¯æ¬¡ä¼˜åŒ–åéƒ½è¦è¿›è¡Œæ€§èƒ½æµ‹è¯•
3. **ç›‘æ§å‘Šè­¦**: è®¾ç½®æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
4. **èµ„æºç®¡ç†**: åˆç†ç®¡ç†æ•°æ®åº“å’ŒRedisè¿æ¥
5. **é”™è¯¯å¤„ç†**: å®Œå–„é”™è¯¯å¤„ç†å’Œé™çº§æœºåˆ¶

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æ•°æ®åº“ä¼˜åŒ–

- ä½¿ç”¨è¿æ¥æ± ç®¡ç†è¿æ¥
- ä¼˜åŒ–æŸ¥è¯¢è¯­å¥å’Œç´¢å¼•
- ç›‘æ§æ…¢æŸ¥è¯¢å’Œæ€§èƒ½æŒ‡æ ‡
- å®ç°æŸ¥è¯¢ç¼“å­˜ç­–ç•¥

### 2. Redisä¼˜åŒ–

- ä½¿ç”¨è¿æ¥æ± ç®¡ç†è¿æ¥
- å®ç°åˆç†çš„ç¼“å­˜ç­–ç•¥
- ç›‘æ§å†…å­˜ä½¿ç”¨å’Œå‘½ä»¤æ‰§è¡Œ
- å®ç°ç¼“å­˜å¤±æ•ˆæœºåˆ¶

### 3. APIæ€§èƒ½ä¼˜åŒ–

- å®ç°è¯·æ±‚é™æµå’Œå‹ç¼©
- ç›‘æ§å“åº”æ—¶é—´å’Œé”™è¯¯ç‡
- ä¼˜åŒ–èµ„æºä½¿ç”¨å’Œå¹¶å‘å¤„ç†
- å®ç°æ€§èƒ½å‘Šè­¦æœºåˆ¶

**è®°ä½: å¥½çš„åç«¯æ€§èƒ½æ˜¯åº”ç”¨ç¨³å®šæ€§çš„åŸºç¡€ï¼ŒæŒç»­çš„æ€§èƒ½ä¼˜åŒ–ç¡®ä¿åº”ç”¨çš„é«˜å¯ç”¨æ€§å’Œç”¨æˆ·ä½“éªŒã€‚**

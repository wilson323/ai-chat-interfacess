# 后端性能优化方案

## 🎯 性能优化目标

### 1. 核心指标

- **API响应时间**: < 500ms (95%请求)
- **数据库查询时间**: < 100ms (95%查询)
- **Redis响应时间**: < 10ms (95%操作)
- **并发处理能力**: > 1000 QPS
- **内存使用率**: < 80%
- **CPU使用率**: < 70%

### 2. 性能预算

- **数据库连接池**: 最大20个连接
- **Redis连接池**: 最大50个连接
- **API超时**: 30秒
- **数据库超时**: 10秒
- **Redis超时**: 5秒

## 🏗️ 优化策略

### 1. 数据库优化

```typescript
// 连接池优化
const poolConfig = {
  max: 20, // 最大连接数
  min: 5, // 最小连接数
  acquire: 30000, // 获取连接超时
  idle: 10000, // 空闲连接超时
  evict: 1000, // 清理间隔
  handleDisconnects: true,
};

// 查询优化
const queryConfig = {
  raw: false, // 返回对象而非数组
  nest: true, // 嵌套对象
  plain: false, // 返回数组
  benchmark: true, // 性能监控
};
```

### 2. Redis缓存优化

```typescript
// 连接池配置
const redisConfig = {
  host: 'localhost',
  port: 6379,
  password: '',
  db: 0,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3,
  lazyConnect: true,
  keepAlive: 30000,
  family: 4,
  connectTimeout: 10000,
  commandTimeout: 5000,
};

// 缓存策略
const cacheStrategy = {
  agents: { ttl: 300, maxSize: 1000 },
  config: { ttl: 600, maxSize: 100 },
  sessions: { ttl: 3600, maxSize: 10000 },
  api_responses: { ttl: 60, maxSize: 5000 },
};
```

### 3. API性能优化

```typescript
// 请求限流
const rateLimitConfig = {
  windowMs: 60000, // 1分钟
  max: 100, // 最大请求数
  standardHeaders: true,
  legacyHeaders: false,
};

// 响应压缩
const compressionConfig = {
  level: 6,
  threshold: 1024,
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
};
```

## 🔧 技术实现

### 1. 数据库连接池优化

```typescript
// lib/db/connection-pool.ts
import { Sequelize } from 'sequelize';
import { appConfig } from '@/lib/config';
import { performanceMonitor } from '@/lib/performance/monitor';

class DatabaseConnectionPool {
  private sequelize: Sequelize;
  private stats = {
    totalConnections: 0,
    activeConnections: 0,
    idleConnections: 0,
    waitingRequests: 0,
  };

  constructor() {
    this.sequelize = new Sequelize(
      appConfig.database.database,
      appConfig.database.username,
      appConfig.database.password,
      {
        host: appConfig.database.host,
        port: appConfig.database.port,
        dialect: 'postgres',
        logging: false,

        // 连接池配置
        pool: {
          max: appConfig.database.pool.max,
          min: appConfig.database.pool.min,
          acquire: appConfig.database.pool.acquire,
          idle: appConfig.database.pool.idle,
          evict: 1000,
          handleDisconnects: true,
        },

        // 重试机制
        retry: {
          max: 3,
          timeout: 60000,
          match: [
            /ETIMEDOUT/,
            /EHOSTUNREACH/,
            /ECONNRESET/,
            /ECONNREFUSED/,
            /SequelizeConnectionError/,
          ],
        },

        // 性能监控
        benchmark: true,

        // 查询优化
        define: {
          freezeTableName: true,
          underscored: true,
          timestamps: true,
          paranoid: false,
        },

        // 查询配置
        query: {
          raw: false,
          nest: true,
          plain: false,
        },
      }
    );

    this.setupEventListeners();
  }

  /**
   * 设置事件监听器
   */
  private setupEventListeners(): void {
    this.sequelize.connectionManager.on('connect', connection => {
      this.stats.totalConnections++;
      this.stats.activeConnections++;
      console.log('Database connection established');
    });

    this.sequelize.connectionManager.on('disconnect', connection => {
      this.stats.activeConnections--;
      console.log('Database connection closed');
    });

    this.sequelize.connectionManager.on('acquire', connection => {
      this.stats.activeConnections++;
      this.stats.idleConnections--;
    });

    this.sequelize.connectionManager.on('release', connection => {
      this.stats.activeConnections--;
      this.stats.idleConnections++;
    });
  }

  /**
   * 获取连接池实例
   */
  getInstance(): Sequelize {
    return this.sequelize;
  }

  /**
   * 获取连接池统计信息
   */
  getStats() {
    return {
      ...this.stats,
      pool: this.sequelize.connectionManager.pool,
    };
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.sequelize.authenticate();
      return true;
    } catch (error) {
      console.error('Database health check failed:', error);
      return false;
    }
  }

  /**
   * 关闭连接池
   */
  async close(): Promise<void> {
    await this.sequelize.close();
  }
}

export const dbPool = new DatabaseConnectionPool();
```

### 2. Redis连接池优化

```typescript
// lib/db/redis-pool.ts
import { createClient, RedisClientType } from 'redis';
import { appConfig } from '@/lib/config';

class RedisConnectionPool {
  private client: RedisClientType;
  private stats = {
    totalConnections: 0,
    activeConnections: 0,
    commandsExecuted: 0,
    errors: 0,
  };

  constructor() {
    this.client = createClient({
      url: `redis://${appConfig.redis.host}:${appConfig.redis.port}`,
      password: appConfig.redis.password,
      database: appConfig.redis.db,

      socket: {
        reconnectStrategy: retries => Math.min(retries * 50, 2000),
        connectTimeout: 10000,
        commandTimeout: 5000,
        keepAlive: 30000,
      },

      // 连接池配置
      commandsQueueMaxLength: 1000,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
    });

    this.setupEventListeners();
  }

  /**
   * 设置事件监听器
   */
  private setupEventListeners(): void {
    this.client.on('connect', () => {
      this.stats.totalConnections++;
      this.stats.activeConnections++;
      console.log('Redis connection established');
    });

    this.client.on('disconnect', () => {
      this.stats.activeConnections--;
      console.log('Redis connection closed');
    });

    this.client.on('error', error => {
      this.stats.errors++;
      console.error('Redis error:', error);
    });

    this.client.on('ready', () => {
      console.log('Redis client ready');
    });
  }

  /**
   * 连接Redis
   */
  async connect(): Promise<void> {
    if (!this.client.isOpen) {
      await this.client.connect();
    }
  }

  /**
   * 断开连接
   */
  async disconnect(): Promise<void> {
    if (this.client.isOpen) {
      await this.client.disconnect();
    }
  }

  /**
   * 获取客户端实例
   */
  getClient(): RedisClientType {
    return this.client;
  }

  /**
   * 执行命令
   */
  async executeCommand<T>(command: () => Promise<T>): Promise<T> {
    try {
      const result = await command();
      this.stats.commandsExecuted++;
      return result;
    } catch (error) {
      this.stats.errors++;
      throw error;
    }
  }

  /**
   * 获取统计信息
   */
  getStats() {
    return {
      ...this.stats,
      isConnected: this.client.isOpen,
    };
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.client.ping();
      return true;
    } catch (error) {
      console.error('Redis health check failed:', error);
      return false;
    }
  }
}

export const redisPool = new RedisConnectionPool();
```

### 3. 缓存策略优化

```typescript
// lib/cache/redis-cache.ts
import { redisPool } from '@/lib/db/redis-pool';
import { performanceMonitor } from '@/lib/performance/monitor';

interface CacheOptions {
  ttl?: number;
  tags?: string[];
  compress?: boolean;
}

class RedisCacheManager {
  private defaultTTL = 300; // 5分钟
  private compressionThreshold = 1024; // 1KB

  /**
   * 设置缓存
   */
  async set<T>(
    key: string,
    value: T,
    options: CacheOptions = {}
  ): Promise<void> {
    const startTime = Date.now();

    try {
      const { ttl = this.defaultTTL, tags = [], compress = false } = options;

      let serializedValue: string;

      if (
        compress &&
        JSON.stringify(value).length > this.compressionThreshold
      ) {
        // 压缩大对象
        serializedValue = await this.compress(JSON.stringify(value));
      } else {
        serializedValue = JSON.stringify(value);
      }

      await redisPool.executeCommand(async () => {
        const pipeline = redisPool.getClient().multi();

        // 设置主键
        pipeline.setex(key, ttl, serializedValue);

        // 设置标签
        if (tags.length > 0) {
          tags.forEach(tag => {
            pipeline.sadd(`tag:${tag}`, key);
            pipeline.expire(`tag:${tag}`, ttl);
          });
        }

        await pipeline.exec();
      });

      // 记录性能指标
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric('cache_set_duration', duration);
    } catch (error) {
      console.error('Failed to set cache:', error);
      throw error;
    }
  }

  /**
   * 获取缓存
   */
  async get<T>(key: string): Promise<T | null> {
    const startTime = Date.now();

    try {
      const result = await redisPool.executeCommand(async () => {
        return await redisPool.getClient().get(key);
      });

      if (!result) {
        return null;
      }

      // 检查是否压缩
      let parsedValue: T;
      try {
        parsedValue = JSON.parse(result);
      } catch (error) {
        // 尝试解压缩
        parsedValue = JSON.parse(await this.decompress(result));
      }

      // 记录性能指标
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric('cache_get_duration', duration);

      return parsedValue;
    } catch (error) {
      console.error('Failed to get cache:', error);
      return null;
    }
  }

  /**
   * 删除缓存
   */
  async delete(key: string): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        await redisPool.getClient().del(key);
      });
    } catch (error) {
      console.error('Failed to delete cache:', error);
      throw error;
    }
  }

  /**
   * 按标签删除缓存
   */
  async deleteByTag(tag: string): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        const keys = await redisPool.getClient().smembers(`tag:${tag}`);
        if (keys.length > 0) {
          await redisPool.getClient().del(keys);
        }
        await redisPool.getClient().del(`tag:${tag}`);
      });
    } catch (error) {
      console.error('Failed to delete cache by tag:', error);
      throw error;
    }
  }

  /**
   * 清空所有缓存
   */
  async clear(): Promise<void> {
    try {
      await redisPool.executeCommand(async () => {
        await redisPool.getClient().flushdb();
      });
    } catch (error) {
      console.error('Failed to clear cache:', error);
      throw error;
    }
  }

  /**
   * 获取缓存统计
   */
  async getStats() {
    try {
      const info = await redisPool.executeCommand(async () => {
        return await redisPool.getClient().info('memory');
      });

      return {
        memory: this.parseRedisInfo(info),
        pool: redisPool.getStats(),
      };
    } catch (error) {
      console.error('Failed to get cache stats:', error);
      return null;
    }
  }

  /**
   * 压缩数据
   */
  private async compress(data: string): Promise<string> {
    // 这里可以使用zlib或其他压缩库
    // 简化实现，实际项目中应该使用真正的压缩
    return Buffer.from(data).toString('base64');
  }

  /**
   * 解压缩数据
   */
  private async decompress(data: string): Promise<string> {
    // 这里可以使用zlib或其他压缩库
    // 简化实现，实际项目中应该使用真正的解压缩
    return Buffer.from(data, 'base64').toString();
  }

  /**
   * 解析Redis信息
   */
  private parseRedisInfo(info: string): any {
    const lines = info.split('\r\n');
    const result: any = {};

    lines.forEach(line => {
      if (line.includes(':')) {
        const [key, value] = line.split(':');
        result[key] = isNaN(Number(value)) ? value : Number(value);
      }
    });

    return result;
  }
}

export const redisCache = new RedisCacheManager();
```

### 4. API性能监控

```typescript
// lib/monitoring/api-performance.ts
import { NextRequest, NextResponse } from 'next/server';
import { performanceMonitor } from '@/lib/performance/monitor';

interface APIMetrics {
  endpoint: string;
  method: string;
  duration: number;
  statusCode: number;
  timestamp: number;
  userAgent: string;
  ip: string;
}

class APIPerformanceMonitor {
  private metrics: APIMetrics[] = [];
  private maxMetrics = 1000;

  /**
   * 记录API性能指标
   */
  recordAPIMetrics(
    endpoint: string,
    method: string,
    duration: number,
    statusCode: number,
    request: NextRequest
  ): void {
    const metric: APIMetrics = {
      endpoint,
      method,
      duration,
      statusCode,
      timestamp: Date.now(),
      userAgent: request.headers.get('user-agent') || 'unknown',
      ip: this.getClientIP(request),
    };

    this.metrics.push(metric);

    // 保持指标数量在限制内
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }

    // 记录到性能监控器
    performanceMonitor.recordMetric('api_duration', duration);
    performanceMonitor.recordMetric(`api_${endpoint}_duration`, duration);
  }

  /**
   * 获取API性能统计
   */
  getAPIStats(): {
    totalRequests: number;
    averageDuration: number;
    slowestEndpoints: Array<{ endpoint: string; duration: number }>;
    errorRate: number;
    requestsPerMinute: number;
  } {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;

    const recentMetrics = this.metrics.filter(m => m.timestamp > oneMinuteAgo);
    const totalDuration = this.metrics.reduce((sum, m) => sum + m.duration, 0);
    const errorCount = this.metrics.filter(m => m.statusCode >= 400).length;

    // 最慢的端点
    const endpointDurations = this.metrics.reduce(
      (acc, m) => {
        if (!acc[m.endpoint]) {
          acc[m.endpoint] = { total: 0, count: 0 };
        }
        acc[m.endpoint].total += m.duration;
        acc[m.endpoint].count += 1;
        return acc;
      },
      {} as Record<string, { total: number; count: number }>
    );

    const slowestEndpoints = Object.entries(endpointDurations)
      .map(([endpoint, stats]) => ({
        endpoint,
        duration: stats.total / stats.count,
      }))
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 10);

    return {
      totalRequests: this.metrics.length,
      averageDuration:
        this.metrics.length > 0 ? totalDuration / this.metrics.length : 0,
      slowestEndpoints,
      errorRate: this.metrics.length > 0 ? errorCount / this.metrics.length : 0,
      requestsPerMinute: recentMetrics.length,
    };
  }

  /**
   * 获取客户端IP
   */
  private getClientIP(request: NextRequest): string {
    const forwarded = request.headers.get('x-forwarded-for');
    const realIP = request.headers.get('x-real-ip');

    if (forwarded) {
      return forwarded.split(',')[0].trim();
    }

    if (realIP) {
      return realIP;
    }

    return 'unknown';
  }

  /**
   * 清理旧指标
   */
  cleanup(): void {
    const oneHourAgo = Date.now() - 3600000;
    this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo);
  }
}

export const apiPerformanceMonitor = new APIPerformanceMonitor();

/**
 * API性能监控中间件
 */
export function withAPIPerformanceMonitoring(handler: Function) {
  return async (request: NextRequest) => {
    const startTime = Date.now();
    const url = new URL(request.url);
    const endpoint = url.pathname;
    const method = request.method;

    try {
      const response = await handler(request);
      const duration = Date.now() - startTime;

      // 记录性能指标
      apiPerformanceMonitor.recordAPIMetrics(
        endpoint,
        method,
        duration,
        response.status,
        request
      );

      return response;
    } catch (error) {
      const duration = Date.now() - startTime;

      // 记录错误性能指标
      apiPerformanceMonitor.recordAPIMetrics(
        endpoint,
        method,
        duration,
        500,
        request
      );

      throw error;
    }
  };
}
```

### 5. 数据库查询优化

```typescript
// lib/db/query-optimizer.ts
import { Sequelize, QueryInterface } from 'sequelize';
import { dbPool } from './connection-pool';

class QueryOptimizer {
  private sequelize: Sequelize;

  constructor() {
    this.sequelize = dbPool.getInstance();
  }

  /**
   * 优化查询
   */
  async optimizeQuery<T>(
    query: string,
    replacements?: any,
    options?: {
      useCache?: boolean;
      cacheTTL?: number;
      explain?: boolean;
    }
  ): Promise<T[]> {
    const { useCache = true, cacheTTL = 300, explain = false } = options || {};

    // 生成缓存键
    const cacheKey = this.generateCacheKey(query, replacements);

    // 尝试从缓存获取
    if (useCache) {
      const cached = await this.getFromCache<T>(cacheKey);
      if (cached) {
        return cached;
      }
    }

    // 执行查询
    const startTime = Date.now();

    try {
      let result: T[];

      if (explain) {
        // 执行EXPLAIN查询
        const explainQuery = `EXPLAIN (ANALYZE, BUFFERS) ${query}`;
        const explainResult = await this.sequelize.query(explainQuery, {
          replacements,
          type: Sequelize.QueryTypes.SELECT,
        });

        console.log('Query Plan:', explainResult);
      }

      result = (await this.sequelize.query(query, {
        replacements,
        type: Sequelize.QueryTypes.SELECT,
      })) as T[];

      const duration = Date.now() - startTime;

      // 记录查询性能
      this.recordQueryMetrics(query, duration, result.length);

      // 缓存结果
      if (useCache) {
        await this.setCache(cacheKey, result, cacheTTL);
      }

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error('Query failed:', { query, duration, error });
      throw error;
    }
  }

  /**
   * 批量查询优化
   */
  async batchQuery<T>(
    queries: Array<{
      query: string;
      replacements?: any;
      key: string;
    }>
  ): Promise<Record<string, T[]>> {
    const results: Record<string, T[]> = {};

    // 并行执行查询
    const promises = queries.map(async ({ query, replacements, key }) => {
      try {
        const result = await this.optimizeQuery<T>(query, replacements);
        return { key, result };
      } catch (error) {
        console.error(`Batch query failed for key ${key}:`, error);
        return { key, result: [] };
      }
    });

    const resolved = await Promise.all(promises);

    resolved.forEach(({ key, result }) => {
      results[key] = result;
    });

    return results;
  }

  /**
   * 生成缓存键
   */
  private generateCacheKey(query: string, replacements?: any): string {
    const hash = this.hashString(query + JSON.stringify(replacements || {}));
    return `query:${hash}`;
  }

  /**
   * 从缓存获取
   */
  private async getFromCache<T>(key: string): Promise<T[] | null> {
    try {
      const { redisCache } = await import('@/lib/cache/redis-cache');
      return await redisCache.get<T[]>(key);
    } catch (error) {
      console.warn('Failed to get from cache:', error);
      return null;
    }
  }

  /**
   * 设置缓存
   */
  private async setCache<T>(
    key: string,
    data: T[],
    ttl: number
  ): Promise<void> {
    try {
      const { redisCache } = await import('@/lib/cache/redis-cache');
      await redisCache.set(key, data, { ttl });
    } catch (error) {
      console.warn('Failed to set cache:', error);
    }
  }

  /**
   * 记录查询性能指标
   */
  private recordQueryMetrics(
    query: string,
    duration: number,
    rowCount: number
  ): void {
    // 记录到性能监控器
    const { performanceMonitor } = require('@/lib/performance/monitor');
    performanceMonitor.recordMetric('db_query_duration', duration);
    performanceMonitor.recordMetric('db_query_rows', rowCount);

    // 记录慢查询
    if (duration > 1000) {
      console.warn('Slow query detected:', { query, duration, rowCount });
    }
  }

  /**
   * 字符串哈希
   */
  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // 转换为32位整数
    }
    return Math.abs(hash).toString(36);
  }
}

export const queryOptimizer = new QueryOptimizer();
```

## 📊 性能监控仪表板

### 1. 实时性能监控

```typescript
// app/api/admin/performance/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { dbPool } from '@/lib/db/connection-pool';
import { redisPool } from '@/lib/db/redis-pool';
import { apiPerformanceMonitor } from '@/lib/monitoring/api-performance';
import { redisCache } from '@/lib/cache/redis-cache';

export async function GET(request: NextRequest) {
  try {
    // 获取数据库性能指标
    const dbStats = dbPool.getStats();
    const dbHealth = await dbPool.healthCheck();

    // 获取Redis性能指标
    const redisStats = redisPool.getStats();
    const redisHealth = await redisPool.healthCheck();

    // 获取API性能指标
    const apiStats = apiPerformanceMonitor.getAPIStats();

    // 获取缓存统计
    const cacheStats = await redisCache.getStats();

    // 获取系统资源使用情况
    const systemStats = {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      cpu: process.cpuUsage(),
    };

    return NextResponse.json({
      success: true,
      data: {
        database: {
          health: dbHealth,
          stats: dbStats,
        },
        redis: {
          health: redisHealth,
          stats: redisStats,
        },
        api: apiStats,
        cache: cacheStats,
        system: systemStats,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error('Failed to get performance metrics:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to get performance metrics',
      },
      { status: 500 }
    );
  }
}
```

## 📋 性能优化检查清单

### 数据库优化检查

- [ ] 连接池配置优化
- [ ] 查询语句优化
- [ ] 索引优化
- [ ] 慢查询监控
- [ ] 连接池监控

### Redis优化检查

- [ ] 连接池配置优化
- [ ] 缓存策略优化
- [ ] 内存使用监控
- [ ] 命令执行监控
- [ ] 错误处理优化

### API性能检查

- [ ] 响应时间监控
- [ ] 并发处理能力
- [ ] 错误率监控
- [ ] 资源使用监控
- [ ] 性能告警设置

## ⚠️ 注意事项

1. **渐进式优化**: 逐步实施优化策略，避免影响现有功能
2. **性能测试**: 每次优化后都要进行性能测试
3. **监控告警**: 设置性能监控和告警机制
4. **资源管理**: 合理管理数据库和Redis连接
5. **错误处理**: 完善错误处理和降级机制

## 🎯 最佳实践

### 1. 数据库优化

- 使用连接池管理连接
- 优化查询语句和索引
- 监控慢查询和性能指标
- 实现查询缓存策略

### 2. Redis优化

- 使用连接池管理连接
- 实现合理的缓存策略
- 监控内存使用和命令执行
- 实现缓存失效机制

### 3. API性能优化

- 实现请求限流和压缩
- 监控响应时间和错误率
- 优化资源使用和并发处理
- 实现性能告警机制

**记住: 好的后端性能是应用稳定性的基础，持续的性能优化确保应用的高可用性和用户体验。**

# å‰ç«¯æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç›®æ ‡

### 1. æ ¸å¿ƒæŒ‡æ ‡

- **é¦–å±åŠ è½½æ—¶é—´**: < 3ç§’
- **æœ€å¤§å†…å®¹ç»˜åˆ¶(LCP)**: < 2.5ç§’
- **é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ(FID)**: < 100ms
- **ç´¯ç§¯å¸ƒå±€åç§»(CLS)**: < 0.1
- **äº¤äº’åˆ°ä¸‹æ¬¡ç»˜åˆ¶(INP)**: < 200ms

### 2. æ€§èƒ½é¢„ç®—

- **JavaScriptåŒ…å¤§å°**: < 500KB (gzipped)
- **CSSåŒ…å¤§å°**: < 100KB (gzipped)
- **å›¾ç‰‡èµ„æº**: < 1MB (æ€»å¤§å°)
- **å­—ä½“èµ„æº**: < 200KB (æ€»å¤§å°)

## ğŸ—ï¸ ä¼˜åŒ–ç­–ç•¥

### 1. ä»£ç åˆ†å‰²ç­–ç•¥

```typescript
// è·¯ç”±çº§åˆ«ä»£ç åˆ†å‰²
const ChatPage = lazy(() => import('@/app/user/chat/page'));
const AdminPage = lazy(() => import('@/app/admin/page'));
const CADAnalyzer = lazy(
  () => import('@/components/cad-analyzer/cad-analyzer-container')
);

// ç»„ä»¶çº§åˆ«ä»£ç åˆ†å‰²
const VoiceRecorder = lazy(() => import('@/components/voice/voice-recorder'));
const ImageEditor = lazy(
  () => import('@/components/image-editor/image-editor-container')
);

// åŠŸèƒ½çº§åˆ«ä»£ç åˆ†å‰²
const AgentManagement = lazy(
  () => import('@/components/admin/agent-management')
);
const ErrorMonitor = lazy(() => import('@/components/admin/error-monitor'));
```

### 2. æ‡’åŠ è½½ç­–ç•¥

```typescript
// å›¾ç‰‡æ‡’åŠ è½½
const LazyImage = ({ src, alt, ...props }) => {
  const [isLoaded, setIsLoaded] = useState(false)
  const [isInView, setIsInView] = useState(false)
  const imgRef = useRef<HTMLImageElement>(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsInView(true)
          observer.unobserve(imgRef.current!)
        }
      },
      { rootMargin: '200px' }
    )

    if (imgRef.current) {
      observer.observe(imgRef.current)
    }

    return () => observer.disconnect()
  }, [])

  return (
    <img
      ref={imgRef}
      src={isInView ? src : '/placeholder.svg'}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      loading="lazy"
      {...props}
    />
  )
}

// ç»„ä»¶æ‡’åŠ è½½
const LazyComponent = ({ children, fallback }) => {
  const [isVisible, setIsVisible] = useState(false)
  const ref = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsVisible(true)
          observer.disconnect()
        }
      },
      { rootMargin: '100px' }
    )

    if (ref.current) {
      observer.observe(ref.current)
    }

    return () => observer.disconnect()
  }, [])

  return (
    <div ref={ref}>
      {isVisible ? children : fallback}
    </div>
  )
}
```

### 3. ç¼“å­˜ç­–ç•¥

```typescript
// æµè§ˆå™¨ç¼“å­˜ç­–ç•¥
const cacheConfig = {
  // é™æ€èµ„æºç¼“å­˜
  static: {
    '*.js': '1y',
    '*.css': '1y',
    '*.png': '1y',
    '*.jpg': '1y',
    '*.svg': '1y',
    '*.woff2': '1y',
  },
  // APIç¼“å­˜
  api: {
    '/api/agents': '5m',
    '/api/config': '10m',
    '/api/health': '1m',
  },
  // é¡µé¢ç¼“å­˜
  pages: {
    '/': '1h',
    '/admin': '30m',
    '/user': '1h',
  },
};

// Service Workerç¼“å­˜
const swCacheStrategy = {
  // ç¼“å­˜ä¼˜å…ˆ
  cacheFirst: ['*.js', '*.css', '*.png', '*.jpg'],
  // ç½‘ç»œä¼˜å…ˆ
  networkFirst: ['/api/chat', '/api/voice'],
  // ä»…ç¼“å­˜
  cacheOnly: ['/offline.html'],
  // ä»…ç½‘ç»œ
  networkOnly: ['/api/auth'],
};
```

## ğŸ”§ æŠ€æœ¯å®ç°

### 1. ä»£ç åˆ†å‰²å®ç°

```typescript
// lib/lazy-loading.tsx
import { lazy, Suspense, ComponentType } from 'react'
import { Loader2 } from 'lucide-react'

/**
 * æ‡’åŠ è½½ç»„ä»¶åŒ…è£…å™¨
 */
export function withLazyLoading<T extends ComponentType<any>>(
  importFunc: () => Promise<{ default: T }>,
  fallback?: React.ReactNode
) {
  const LazyComponent = lazy(importFunc)

  return function LazyWrapper(props: any) {
    return (
      <Suspense fallback={fallback || <DefaultFallback />}>
        <LazyComponent {...props} />
      </Suspense>
    )
  }
}

/**
 * é»˜è®¤åŠ è½½ç»„ä»¶
 */
function DefaultFallback() {
  return (
    <div className="flex items-center justify-center p-8">
      <Loader2 className="h-8 w-8 animate-spin text-primary" />
    </div>
  )
}

/**
 * é¢„åŠ è½½ç»„ä»¶
 */
export function preloadComponent(importFunc: () => Promise<any>) {
  return () => {
    importFunc()
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export const LazyChatPage = withLazyLoading(() => import('@/app/user/chat/page'))
export const LazyAdminPage = withLazyLoading(() => import('@/app/admin/page'))
export const LazyCADAnalyzer = withLazyLoading(() => import('@/components/cad-analyzer/cad-analyzer-container'))
```

### 2. å›¾ç‰‡ä¼˜åŒ–å®ç°

```typescript
// components/optimized-image.tsx
import { useState, useRef, useEffect } from 'react'
import { cn } from '@/lib/utils'

interface OptimizedImageProps {
  src: string
  alt: string
  width?: number
  height?: number
  quality?: number
  placeholder?: 'blur' | 'empty'
  blurDataURL?: string
  priority?: boolean
  className?: string
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  quality = 75,
  placeholder = 'blur',
  blurDataURL,
  priority = false,
  className,
  ...props
}: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false)
  const [isInView, setIsInView] = useState(priority)
  const [hasError, setHasError] = useState(false)
  const imgRef = useRef<HTMLImageElement>(null)

  // ç”Ÿæˆä¼˜åŒ–çš„å›¾ç‰‡URL
  const optimizedSrc = generateOptimizedImageUrl(src, {
    width,
    height,
    quality,
    format: 'webp'
  })

  // ç”Ÿæˆå ä½ç¬¦
  const placeholderSrc = blurDataURL || generatePlaceholder(width, height)

  // æ‡’åŠ è½½é€»è¾‘
  useEffect(() => {
    if (priority) return

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsInView(true)
          observer.disconnect()
        }
      },
      { rootMargin: '200px' }
    )

    if (imgRef.current) {
      observer.observe(imgRef.current)
    }

    return () => observer.disconnect()
  }, [priority])

  const handleLoad = () => {
    setIsLoaded(true)
  }

  const handleError = () => {
    setHasError(true)
  }

  return (
    <div className="relative overflow-hidden">
      {/* å ä½ç¬¦ */}
      {!isLoaded && !hasError && (
        <div
          className={cn(
            'absolute inset-0 bg-muted animate-pulse',
            placeholder === 'blur' && 'blur-sm'
          )}
          style={{
            backgroundImage: `url(${placeholderSrc})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center'
          }}
        />
      )}

      {/* å®é™…å›¾ç‰‡ */}
      {isInView && (
        <img
          ref={imgRef}
          src={optimizedSrc}
          alt={alt}
          width={width}
          height={height}
          className={cn(
            'transition-opacity duration-300',
            isLoaded ? 'opacity-100' : 'opacity-0',
            className
          )}
          onLoad={handleLoad}
          onError={handleError}
          loading={priority ? 'eager' : 'lazy'}
          {...props}
        />
      )}

      {/* é”™è¯¯çŠ¶æ€ */}
      {hasError && (
        <div className="absolute inset-0 flex items-center justify-center bg-muted">
          <span className="text-muted-foreground">å›¾ç‰‡åŠ è½½å¤±è´¥</span>
        </div>
      )}
    </div>
  )
}

/**
 * ç”Ÿæˆä¼˜åŒ–çš„å›¾ç‰‡URL
 */
function generateOptimizedImageUrl(
  src: string,
  options: {
    width?: number
    height?: number
    quality?: number
    format?: 'webp' | 'jpeg' | 'png'
  }
): string {
  // è¿™é‡Œå¯ä»¥é›†æˆå›¾ç‰‡ä¼˜åŒ–æœåŠ¡ï¼Œå¦‚Cloudinaryã€ImageKitç­‰
  const params = new URLSearchParams()

  if (options.width) params.set('w', options.width.toString())
  if (options.height) params.set('h', options.height.toString())
  if (options.quality) params.set('q', options.quality.toString())
  if (options.format) params.set('f', options.format)

  return `${src}?${params.toString()}`
}

/**
 * ç”Ÿæˆå ä½ç¬¦
 */
function generatePlaceholder(width?: number, height?: number): string {
  const w = width || 400
  const h = height || 300
  return `data:image/svg+xml;base64,${btoa(`
    <svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" text-anchor="middle" dy=".3em" fill="#9ca3af">Loading...</text>
    </svg>
  `)}`
}
```

### 3. çŠ¶æ€ç®¡ç†ä¼˜åŒ–

```typescript
// hooks/use-optimized-state.ts
import { useState, useCallback, useMemo, useRef } from 'react';

/**
 * ä¼˜åŒ–çš„çŠ¶æ€ç®¡ç†Hook
 */
export function useOptimizedState<T>(initialValue: T) {
  const [state, setState] = useState(initialValue);
  const stateRef = useRef(state);

  // ä½¿ç”¨useCallbacké¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
  const setOptimizedState = useCallback((newState: T | ((prev: T) => T)) => {
    const nextState =
      typeof newState === 'function'
        ? (newState as (prev: T) => T)(stateRef.current)
        : newState;

    if (nextState !== stateRef.current) {
      stateRef.current = nextState;
      setState(nextState);
    }
  }, []);

  return [state, setOptimizedState] as const;
}

/**
 * é˜²æŠ–çŠ¶æ€Hook
 */
export function useDebouncedState<T>(initialValue: T, delay: number = 300) {
  const [state, setState] = useState(initialValue);
  const timeoutRef = useRef<NodeJS.Timeout>();

  const setDebouncedState = useCallback(
    (newState: T) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        setState(newState);
      }, delay);
    },
    [delay]
  );

  return [state, setDebouncedState] as const;
}

/**
 * èŠ‚æµçŠ¶æ€Hook
 */
export function useThrottledState<T>(initialValue: T, delay: number = 100) {
  const [state, setState] = useState(initialValue);
  const lastUpdateRef = useRef(0);

  const setThrottledState = useCallback(
    (newState: T) => {
      const now = Date.now();

      if (now - lastUpdateRef.current >= delay) {
        setState(newState);
        lastUpdateRef.current = now;
      }
    },
    [delay]
  );

  return [state, setThrottledState] as const;
}
```

### 4. è™šæ‹Ÿæ»šåŠ¨å®ç°

```typescript
// components/virtualized-list.tsx
import { useState, useEffect, useRef, useMemo } from 'react'

interface VirtualizedListProps<T> {
  items: T[]
  itemHeight: number
  containerHeight: number
  renderItem: (item: T, index: number) => React.ReactNode
  overscan?: number
}

export function VirtualizedList<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualizedListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0)
  const containerRef = useRef<HTMLDivElement>(null)

  // è®¡ç®—å¯è§èŒƒå›´
  const visibleRange = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight)
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + overscan,
      items.length - 1
    )

    return {
      start: Math.max(0, startIndex - overscan),
      end: endIndex
    }
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan])

  // å¯è§é¡¹ç›®
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.start, visibleRange.end + 1)
  }, [items, visibleRange])

  // æ€»é«˜åº¦
  const totalHeight = items.length * itemHeight

  // åç§»é‡
  const offsetY = visibleRange.start * itemHeight

  // æ»šåŠ¨å¤„ç†
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop)
  }

  return (
    <div
      ref={containerRef}
      className="overflow-auto"
      style={{ height: containerHeight }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={visibleRange.start + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, visibleRange.start + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 5. ç¼“å­˜ç­–ç•¥å®ç°

```typescript
// lib/cache/performance-cache.ts
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class PerformanceCache {
  private cache = new Map<string, CacheEntry<any>>();
  private maxSize = 1000;

  /**
   * è®¾ç½®ç¼“å­˜
   */
  set<T>(key: string, data: T, ttl: number = 300000): void {
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    this.cleanup();

    // æ£€æŸ¥ç¼“å­˜å¤§å°
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    });
  }

  /**
   * è·å–ç¼“å­˜
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  /**
   * åˆ é™¤ç¼“å­˜
   */
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  private cleanup(): void {
    const now = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * æ·˜æ±°æœ€æ—§çš„ç¼“å­˜
   */
  private evictOldest(): void {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (entry.timestamp < oldestTime) {
        oldestTime = entry.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: this.calculateHitRate(),
    };
  }

  private hits = 0;
  private misses = 0;

  private calculateHitRate(): number {
    const total = this.hits + this.misses;
    return total > 0 ? this.hits / total : 0;
  }
}

export const performanceCache = new PerformanceCache();
```

### 6. æ€§èƒ½ç›‘æ§å®ç°

```typescript
// lib/performance/monitor.ts
interface PerformanceMetrics {
  lcp: number;
  fid: number;
  cls: number;
  inp: number;
  ttfb: number;
  fcp: number;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    lcp: 0,
    fid: 0,
    cls: 0,
    inp: 0,
    ttfb: 0,
    fcp: 0,
  };

  /**
   * åˆå§‹åŒ–æ€§èƒ½ç›‘æ§
   */
  init(): void {
    this.observeLCP();
    this.observeFID();
    this.observeCLS();
    this.observeINP();
    this.observeTTFB();
    this.observeFCP();
  }

  /**
   * è§‚å¯Ÿæœ€å¤§å†…å®¹ç»˜åˆ¶
   */
  private observeLCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
    });

    observer.observe({ entryTypes: ['largest-contentful-paint'] });
  }

  /**
   * è§‚å¯Ÿé¦–æ¬¡è¾“å…¥å»¶è¿Ÿ
   */
  private observeFID(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        this.metrics.fid = entry.processingStart - entry.startTime;
      });
    });

    observer.observe({ entryTypes: ['first-input'] });
  }

  /**
   * è§‚å¯Ÿç´¯ç§¯å¸ƒå±€åç§»
   */
  private observeCLS(): void {
    let clsValue = 0;

    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      this.metrics.cls = clsValue;
    });

    observer.observe({ entryTypes: ['layout-shift'] });
  }

  /**
   * è§‚å¯Ÿäº¤äº’åˆ°ä¸‹æ¬¡ç»˜åˆ¶
   */
  private observeINP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        this.metrics.inp = entry.processingEnd - entry.startTime;
      });
    });

    observer.observe({ entryTypes: ['event'] });
  }

  /**
   * è§‚å¯Ÿé¦–å­—èŠ‚æ—¶é—´
   */
  private observeTTFB(): void {
    const navigation = performance.getEntriesByType(
      'navigation'
    )[0] as PerformanceNavigationTiming;
    this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
  }

  /**
   * è§‚å¯Ÿé¦–æ¬¡å†…å®¹ç»˜åˆ¶
   */
  private observeFCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      const fcpEntry = entries.find(
        entry => entry.name === 'first-contentful-paint'
      );
      if (fcpEntry) {
        this.metrics.fcp = fcpEntry.startTime;
      }
    });

    observer.observe({ entryTypes: ['paint'] });
  }

  /**
   * è·å–æ€§èƒ½æŒ‡æ ‡
   */
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  /**
   * æ£€æŸ¥æ€§èƒ½æ˜¯å¦è¾¾æ ‡
   */
  checkPerformance(): boolean {
    const { lcp, fid, cls, inp } = this.metrics;

    return (
      lcp < 2500 && // LCP < 2.5s
      fid < 100 && // FID < 100ms
      cls < 0.1 && // CLS < 0.1
      inp < 200 // INP < 200ms
    );
  }

  /**
   * å‘é€æ€§èƒ½æ•°æ®
   */
  sendMetrics(): void {
    if (typeof window !== 'undefined' && window.navigator.sendBeacon) {
      const data = JSON.stringify({
        metrics: this.metrics,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
      });

      window.navigator.sendBeacon('/api/performance', data);
    }
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å·¥å…·

### 1. Webpacké…ç½®ä¼˜åŒ–

```javascript
// next.config.mjs
const nextConfig = {
  // å¯ç”¨SWCç¼–è¯‘å™¨
  swcMinify: true,

  // å¯ç”¨å®éªŒæ€§åŠŸèƒ½
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['lucide-react', 'framer-motion'],
  },

  // å‹ç¼©é…ç½®
  compress: true,

  // å›¾ç‰‡ä¼˜åŒ–
  images: {
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 31536000, // 1å¹´
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // ç¼–è¯‘å™¨é…ç½®
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },

  // è¾“å‡ºé…ç½®
  output: 'standalone',

  // é‡å†™é…ç½®
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: '/api/:path*',
      },
    ];
  },

  // å¤´éƒ¨é…ç½®
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
        ],
      },
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
```

### 2. æ€§èƒ½æµ‹è¯•è„šæœ¬

```javascript
// scripts/performance-test.js
const { chromium } = require('playwright');

async function runPerformanceTest() {
  const browser = await chromium.launch();
  const page = await browser.newPage();

  // å¯ç”¨æ€§èƒ½ç›‘æ§
  await page.coverage.startJSCoverage();
  await page.coverage.startCSSCoverage();

  // å¯¼èˆªåˆ°é¡µé¢
  await page.goto('http://localhost:3000');

  // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
  await page.waitForLoadState('networkidle');

  // è·å–æ€§èƒ½æŒ‡æ ‡
  const metrics = await page.evaluate(() => {
    return new Promise(resolve => {
      const observer = new PerformanceObserver(list => {
        const entries = list.getEntries();
        const metrics = {};

        entries.forEach(entry => {
          if (entry.entryType === 'navigation') {
            metrics.ttfb = entry.responseStart - entry.requestStart;
            metrics.fcp =
              entry.domContentLoadedEventEnd - entry.navigationStart;
          }
        });

        resolve(metrics);
      });

      observer.observe({ entryTypes: ['navigation'] });
    });
  });

  // è·å–è¦†ç›–ç‡
  const jsCoverage = await page.coverage.stopJSCoverage();
  const cssCoverage = await page.coverage.stopCSSCoverage();

  // è®¡ç®—è¦†ç›–ç‡
  const jsUsedBytes = jsCoverage.reduce(
    (acc, entry) => acc + entry.text.length,
    0
  );
  const jsTotalBytes = jsCoverage.reduce(
    (acc, entry) =>
      acc +
      entry.ranges.reduce((sum, range) => sum + range.end - range.start, 0),
    0
  );
  const jsCoveragePercent = (jsUsedBytes / jsTotalBytes) * 100;

  console.log('Performance Metrics:', metrics);
  console.log('JS Coverage:', `${jsCoveragePercent.toFixed(2)}%`);

  await browser.close();
}

runPerformanceTest().catch(console.error);
```

## ğŸ“‹ æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

### ä»£ç åˆ†å‰²æ£€æŸ¥

- [ ] è·¯ç”±çº§åˆ«ä»£ç åˆ†å‰²
- [ ] ç»„ä»¶çº§åˆ«ä»£ç åˆ†å‰²
- [ ] ç¬¬ä¸‰æ–¹åº“ä»£ç åˆ†å‰²
- [ ] åŠ¨æ€å¯¼å…¥ä½¿ç”¨

### æ‡’åŠ è½½æ£€æŸ¥

- [ ] å›¾ç‰‡æ‡’åŠ è½½
- [ ] ç»„ä»¶æ‡’åŠ è½½
- [ ] è·¯ç”±æ‡’åŠ è½½
- [ ] èµ„æºæ‡’åŠ è½½

### ç¼“å­˜ç­–ç•¥æ£€æŸ¥

- [ ] æµè§ˆå™¨ç¼“å­˜é…ç½®
- [ ] Service Workerç¼“å­˜
- [ ] APIå“åº”ç¼“å­˜
- [ ] é™æ€èµ„æºç¼“å­˜

### æ€§èƒ½ç›‘æ§æ£€æŸ¥

- [ ] Core Web Vitalsç›‘æ§
- [ ] æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- [ ] æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ
- [ ] æ€§èƒ½å‘Šè­¦è®¾ç½®

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **æ¸è¿›å¼ä¼˜åŒ–**: é€æ­¥å®æ–½ä¼˜åŒ–ç­–ç•¥ï¼Œé¿å…ä¸€æ¬¡æ€§å¤§æ”¹
2. **æ€§èƒ½æµ‹è¯•**: æ¯æ¬¡ä¼˜åŒ–åéƒ½è¦è¿›è¡Œæ€§èƒ½æµ‹è¯•
3. **ç”¨æˆ·ä½“éªŒ**: ä¼˜åŒ–ä¸èƒ½å½±å“ç”¨æˆ·ä½“éªŒ
4. **å…¼å®¹æ€§**: ç¡®ä¿ä¼˜åŒ–åçš„ä»£ç åœ¨å„ç§ç¯å¢ƒä¸‹éƒ½èƒ½æ­£å¸¸å·¥ä½œ
5. **ç›‘æ§**: æŒç»­ç›‘æ§æ€§èƒ½æŒ‡æ ‡ï¼ŒåŠæ—¶å‘ç°é—®é¢˜

## ğŸ¯ æœ€ä½³å®è·µ

### 1. ä»£ç åˆ†å‰²

- æŒ‰è·¯ç”±åˆ†å‰²ä»£ç 
- æŒ‰åŠŸèƒ½åˆ†å‰²ä»£ç 
- æŒ‰ç”¨æˆ·æƒé™åˆ†å‰²ä»£ç 
- æŒ‰è®¾å¤‡ç±»å‹åˆ†å‰²ä»£ç 

### 2. æ‡’åŠ è½½

- å›¾ç‰‡æ‡’åŠ è½½
- ç»„ä»¶æ‡’åŠ è½½
- è·¯ç”±æ‡’åŠ è½½
- èµ„æºæ‡’åŠ è½½

### 3. ç¼“å­˜ç­–ç•¥

- é™æ€èµ„æºé•¿æœŸç¼“å­˜
- APIå“åº”çŸ­æœŸç¼“å­˜
- ç”¨æˆ·æ•°æ®æœ¬åœ°ç¼“å­˜
- æœåŠ¡ç«¯ç¼“å­˜

### 4. æ€§èƒ½ç›‘æ§

- å®æ—¶æ€§èƒ½ç›‘æ§
- æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ
- æ€§èƒ½å‘Šè­¦è®¾ç½®

**è®°ä½: å¥½çš„æ€§èƒ½æ˜¯ç”¨æˆ·ä½“éªŒçš„åŸºç¡€ï¼ŒæŒç»­çš„æ€§èƒ½ä¼˜åŒ–ç¡®ä¿åº”ç”¨çš„é«˜å¯ç”¨æ€§å’Œç”¨æˆ·æ»¡æ„åº¦ã€‚**

# 前端性能优化方案

## 🎯 性能优化目标

### 1. 核心指标

- **首屏加载时间**: < 3秒
- **最大内容绘制(LCP)**: < 2.5秒
- **首次输入延迟(FID)**: < 100ms
- **累积布局偏移(CLS)**: < 0.1
- **交互到下次绘制(INP)**: < 200ms

### 2. 性能预算

- **JavaScript包大小**: < 500KB (gzipped)
- **CSS包大小**: < 100KB (gzipped)
- **图片资源**: < 1MB (总大小)
- **字体资源**: < 200KB (总大小)

## 🏗️ 优化策略

### 1. 代码分割策略

```typescript
// 路由级别代码分割
const ChatPage = lazy(() => import('@/app/user/chat/page'));
const AdminPage = lazy(() => import('@/app/admin/page'));
const CADAnalyzer = lazy(
  () => import('@/components/cad-analyzer/cad-analyzer-container')
);

// 组件级别代码分割
const VoiceRecorder = lazy(() => import('@/components/voice/voice-recorder'));
const ImageEditor = lazy(
  () => import('@/components/image-editor/image-editor-container')
);

// 功能级别代码分割
const AgentManagement = lazy(
  () => import('@/components/admin/agent-management')
);
const ErrorMonitor = lazy(() => import('@/components/admin/error-monitor'));
```

### 2. 懒加载策略

```typescript
// 图片懒加载
const LazyImage = ({ src, alt, ...props }) => {
  const [isLoaded, setIsLoaded] = useState(false)
  const [isInView, setIsInView] = useState(false)
  const imgRef = useRef<HTMLImageElement>(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsInView(true)
          observer.unobserve(imgRef.current!)
        }
      },
      { rootMargin: '200px' }
    )

    if (imgRef.current) {
      observer.observe(imgRef.current)
    }

    return () => observer.disconnect()
  }, [])

  return (
    <img
      ref={imgRef}
      src={isInView ? src : '/placeholder.svg'}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      loading="lazy"
      {...props}
    />
  )
}

// 组件懒加载
const LazyComponent = ({ children, fallback }) => {
  const [isVisible, setIsVisible] = useState(false)
  const ref = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsVisible(true)
          observer.disconnect()
        }
      },
      { rootMargin: '100px' }
    )

    if (ref.current) {
      observer.observe(ref.current)
    }

    return () => observer.disconnect()
  }, [])

  return (
    <div ref={ref}>
      {isVisible ? children : fallback}
    </div>
  )
}
```

### 3. 缓存策略

```typescript
// 浏览器缓存策略
const cacheConfig = {
  // 静态资源缓存
  static: {
    '*.js': '1y',
    '*.css': '1y',
    '*.png': '1y',
    '*.jpg': '1y',
    '*.svg': '1y',
    '*.woff2': '1y',
  },
  // API缓存
  api: {
    '/api/agents': '5m',
    '/api/config': '10m',
    '/api/health': '1m',
  },
  // 页面缓存
  pages: {
    '/': '1h',
    '/admin': '30m',
    '/user': '1h',
  },
};

// Service Worker缓存
const swCacheStrategy = {
  // 缓存优先
  cacheFirst: ['*.js', '*.css', '*.png', '*.jpg'],
  // 网络优先
  networkFirst: ['/api/chat', '/api/voice'],
  // 仅缓存
  cacheOnly: ['/offline.html'],
  // 仅网络
  networkOnly: ['/api/auth'],
};
```

## 🔧 技术实现

### 1. 代码分割实现

```typescript
// lib/lazy-loading.tsx
import { lazy, Suspense, ComponentType } from 'react'
import { Loader2 } from 'lucide-react'

/**
 * 懒加载组件包装器
 */
export function withLazyLoading<T extends ComponentType<any>>(
  importFunc: () => Promise<{ default: T }>,
  fallback?: React.ReactNode
) {
  const LazyComponent = lazy(importFunc)

  return function LazyWrapper(props: any) {
    return (
      <Suspense fallback={fallback || <DefaultFallback />}>
        <LazyComponent {...props} />
      </Suspense>
    )
  }
}

/**
 * 默认加载组件
 */
function DefaultFallback() {
  return (
    <div className="flex items-center justify-center p-8">
      <Loader2 className="h-8 w-8 animate-spin text-primary" />
    </div>
  )
}

/**
 * 预加载组件
 */
export function preloadComponent(importFunc: () => Promise<any>) {
  return () => {
    importFunc()
  }
}

// 使用示例
export const LazyChatPage = withLazyLoading(() => import('@/app/user/chat/page'))
export const LazyAdminPage = withLazyLoading(() => import('@/app/admin/page'))
export const LazyCADAnalyzer = withLazyLoading(() => import('@/components/cad-analyzer/cad-analyzer-container'))
```

### 2. 图片优化实现

```typescript
// components/optimized-image.tsx
import { useState, useRef, useEffect } from 'react'
import { cn } from '@/lib/utils'

interface OptimizedImageProps {
  src: string
  alt: string
  width?: number
  height?: number
  quality?: number
  placeholder?: 'blur' | 'empty'
  blurDataURL?: string
  priority?: boolean
  className?: string
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  quality = 75,
  placeholder = 'blur',
  blurDataURL,
  priority = false,
  className,
  ...props
}: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false)
  const [isInView, setIsInView] = useState(priority)
  const [hasError, setHasError] = useState(false)
  const imgRef = useRef<HTMLImageElement>(null)

  // 生成优化的图片URL
  const optimizedSrc = generateOptimizedImageUrl(src, {
    width,
    height,
    quality,
    format: 'webp'
  })

  // 生成占位符
  const placeholderSrc = blurDataURL || generatePlaceholder(width, height)

  // 懒加载逻辑
  useEffect(() => {
    if (priority) return

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsInView(true)
          observer.disconnect()
        }
      },
      { rootMargin: '200px' }
    )

    if (imgRef.current) {
      observer.observe(imgRef.current)
    }

    return () => observer.disconnect()
  }, [priority])

  const handleLoad = () => {
    setIsLoaded(true)
  }

  const handleError = () => {
    setHasError(true)
  }

  return (
    <div className="relative overflow-hidden">
      {/* 占位符 */}
      {!isLoaded && !hasError && (
        <div
          className={cn(
            'absolute inset-0 bg-muted animate-pulse',
            placeholder === 'blur' && 'blur-sm'
          )}
          style={{
            backgroundImage: `url(${placeholderSrc})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center'
          }}
        />
      )}

      {/* 实际图片 */}
      {isInView && (
        <img
          ref={imgRef}
          src={optimizedSrc}
          alt={alt}
          width={width}
          height={height}
          className={cn(
            'transition-opacity duration-300',
            isLoaded ? 'opacity-100' : 'opacity-0',
            className
          )}
          onLoad={handleLoad}
          onError={handleError}
          loading={priority ? 'eager' : 'lazy'}
          {...props}
        />
      )}

      {/* 错误状态 */}
      {hasError && (
        <div className="absolute inset-0 flex items-center justify-center bg-muted">
          <span className="text-muted-foreground">图片加载失败</span>
        </div>
      )}
    </div>
  )
}

/**
 * 生成优化的图片URL
 */
function generateOptimizedImageUrl(
  src: string,
  options: {
    width?: number
    height?: number
    quality?: number
    format?: 'webp' | 'jpeg' | 'png'
  }
): string {
  // 这里可以集成图片优化服务，如Cloudinary、ImageKit等
  const params = new URLSearchParams()

  if (options.width) params.set('w', options.width.toString())
  if (options.height) params.set('h', options.height.toString())
  if (options.quality) params.set('q', options.quality.toString())
  if (options.format) params.set('f', options.format)

  return `${src}?${params.toString()}`
}

/**
 * 生成占位符
 */
function generatePlaceholder(width?: number, height?: number): string {
  const w = width || 400
  const h = height || 300
  return `data:image/svg+xml;base64,${btoa(`
    <svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" text-anchor="middle" dy=".3em" fill="#9ca3af">Loading...</text>
    </svg>
  `)}`
}
```

### 3. 状态管理优化

```typescript
// hooks/use-optimized-state.ts
import { useState, useCallback, useMemo, useRef } from 'react';

/**
 * 优化的状态管理Hook
 */
export function useOptimizedState<T>(initialValue: T) {
  const [state, setState] = useState(initialValue);
  const stateRef = useRef(state);

  // 使用useCallback避免不必要的重渲染
  const setOptimizedState = useCallback((newState: T | ((prev: T) => T)) => {
    const nextState =
      typeof newState === 'function'
        ? (newState as (prev: T) => T)(stateRef.current)
        : newState;

    if (nextState !== stateRef.current) {
      stateRef.current = nextState;
      setState(nextState);
    }
  }, []);

  return [state, setOptimizedState] as const;
}

/**
 * 防抖状态Hook
 */
export function useDebouncedState<T>(initialValue: T, delay: number = 300) {
  const [state, setState] = useState(initialValue);
  const timeoutRef = useRef<NodeJS.Timeout>();

  const setDebouncedState = useCallback(
    (newState: T) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        setState(newState);
      }, delay);
    },
    [delay]
  );

  return [state, setDebouncedState] as const;
}

/**
 * 节流状态Hook
 */
export function useThrottledState<T>(initialValue: T, delay: number = 100) {
  const [state, setState] = useState(initialValue);
  const lastUpdateRef = useRef(0);

  const setThrottledState = useCallback(
    (newState: T) => {
      const now = Date.now();

      if (now - lastUpdateRef.current >= delay) {
        setState(newState);
        lastUpdateRef.current = now;
      }
    },
    [delay]
  );

  return [state, setThrottledState] as const;
}
```

### 4. 虚拟滚动实现

```typescript
// components/virtualized-list.tsx
import { useState, useEffect, useRef, useMemo } from 'react'

interface VirtualizedListProps<T> {
  items: T[]
  itemHeight: number
  containerHeight: number
  renderItem: (item: T, index: number) => React.ReactNode
  overscan?: number
}

export function VirtualizedList<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualizedListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0)
  const containerRef = useRef<HTMLDivElement>(null)

  // 计算可见范围
  const visibleRange = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight)
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + overscan,
      items.length - 1
    )

    return {
      start: Math.max(0, startIndex - overscan),
      end: endIndex
    }
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan])

  // 可见项目
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.start, visibleRange.end + 1)
  }, [items, visibleRange])

  // 总高度
  const totalHeight = items.length * itemHeight

  // 偏移量
  const offsetY = visibleRange.start * itemHeight

  // 滚动处理
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop)
  }

  return (
    <div
      ref={containerRef}
      className="overflow-auto"
      style={{ height: containerHeight }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={visibleRange.start + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, visibleRange.start + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### 5. 缓存策略实现

```typescript
// lib/cache/performance-cache.ts
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class PerformanceCache {
  private cache = new Map<string, CacheEntry<any>>();
  private maxSize = 1000;

  /**
   * 设置缓存
   */
  set<T>(key: string, data: T, ttl: number = 300000): void {
    // 清理过期缓存
    this.cleanup();

    // 检查缓存大小
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    });
  }

  /**
   * 获取缓存
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // 检查是否过期
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  /**
   * 删除缓存
   */
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  /**
   * 清理过期缓存
   */
  private cleanup(): void {
    const now = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * 淘汰最旧的缓存
   */
  private evictOldest(): void {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (entry.timestamp < oldestTime) {
        oldestTime = entry.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  /**
   * 清空缓存
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * 获取缓存统计
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: this.calculateHitRate(),
    };
  }

  private hits = 0;
  private misses = 0;

  private calculateHitRate(): number {
    const total = this.hits + this.misses;
    return total > 0 ? this.hits / total : 0;
  }
}

export const performanceCache = new PerformanceCache();
```

### 6. 性能监控实现

```typescript
// lib/performance/monitor.ts
interface PerformanceMetrics {
  lcp: number;
  fid: number;
  cls: number;
  inp: number;
  ttfb: number;
  fcp: number;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    lcp: 0,
    fid: 0,
    cls: 0,
    inp: 0,
    ttfb: 0,
    fcp: 0,
  };

  /**
   * 初始化性能监控
   */
  init(): void {
    this.observeLCP();
    this.observeFID();
    this.observeCLS();
    this.observeINP();
    this.observeTTFB();
    this.observeFCP();
  }

  /**
   * 观察最大内容绘制
   */
  private observeLCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
    });

    observer.observe({ entryTypes: ['largest-contentful-paint'] });
  }

  /**
   * 观察首次输入延迟
   */
  private observeFID(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        this.metrics.fid = entry.processingStart - entry.startTime;
      });
    });

    observer.observe({ entryTypes: ['first-input'] });
  }

  /**
   * 观察累积布局偏移
   */
  private observeCLS(): void {
    let clsValue = 0;

    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      this.metrics.cls = clsValue;
    });

    observer.observe({ entryTypes: ['layout-shift'] });
  }

  /**
   * 观察交互到下次绘制
   */
  private observeINP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        this.metrics.inp = entry.processingEnd - entry.startTime;
      });
    });

    observer.observe({ entryTypes: ['event'] });
  }

  /**
   * 观察首字节时间
   */
  private observeTTFB(): void {
    const navigation = performance.getEntriesByType(
      'navigation'
    )[0] as PerformanceNavigationTiming;
    this.metrics.ttfb = navigation.responseStart - navigation.requestStart;
  }

  /**
   * 观察首次内容绘制
   */
  private observeFCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries = list.getEntries();
      const fcpEntry = entries.find(
        entry => entry.name === 'first-contentful-paint'
      );
      if (fcpEntry) {
        this.metrics.fcp = fcpEntry.startTime;
      }
    });

    observer.observe({ entryTypes: ['paint'] });
  }

  /**
   * 获取性能指标
   */
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  /**
   * 检查性能是否达标
   */
  checkPerformance(): boolean {
    const { lcp, fid, cls, inp } = this.metrics;

    return (
      lcp < 2500 && // LCP < 2.5s
      fid < 100 && // FID < 100ms
      cls < 0.1 && // CLS < 0.1
      inp < 200 // INP < 200ms
    );
  }

  /**
   * 发送性能数据
   */
  sendMetrics(): void {
    if (typeof window !== 'undefined' && window.navigator.sendBeacon) {
      const data = JSON.stringify({
        metrics: this.metrics,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
      });

      window.navigator.sendBeacon('/api/performance', data);
    }
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## 📊 性能优化工具

### 1. Webpack配置优化

```javascript
// next.config.mjs
const nextConfig = {
  // 启用SWC编译器
  swcMinify: true,

  // 启用实验性功能
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['lucide-react', 'framer-motion'],
  },

  // 压缩配置
  compress: true,

  // 图片优化
  images: {
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 31536000, // 1年
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // 编译器配置
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },

  // 输出配置
  output: 'standalone',

  // 重写配置
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: '/api/:path*',
      },
    ];
  },

  // 头部配置
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
        ],
      },
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
```

### 2. 性能测试脚本

```javascript
// scripts/performance-test.js
const { chromium } = require('playwright');

async function runPerformanceTest() {
  const browser = await chromium.launch();
  const page = await browser.newPage();

  // 启用性能监控
  await page.coverage.startJSCoverage();
  await page.coverage.startCSSCoverage();

  // 导航到页面
  await page.goto('http://localhost:3000');

  // 等待页面加载完成
  await page.waitForLoadState('networkidle');

  // 获取性能指标
  const metrics = await page.evaluate(() => {
    return new Promise(resolve => {
      const observer = new PerformanceObserver(list => {
        const entries = list.getEntries();
        const metrics = {};

        entries.forEach(entry => {
          if (entry.entryType === 'navigation') {
            metrics.ttfb = entry.responseStart - entry.requestStart;
            metrics.fcp =
              entry.domContentLoadedEventEnd - entry.navigationStart;
          }
        });

        resolve(metrics);
      });

      observer.observe({ entryTypes: ['navigation'] });
    });
  });

  // 获取覆盖率
  const jsCoverage = await page.coverage.stopJSCoverage();
  const cssCoverage = await page.coverage.stopCSSCoverage();

  // 计算覆盖率
  const jsUsedBytes = jsCoverage.reduce(
    (acc, entry) => acc + entry.text.length,
    0
  );
  const jsTotalBytes = jsCoverage.reduce(
    (acc, entry) =>
      acc +
      entry.ranges.reduce((sum, range) => sum + range.end - range.start, 0),
    0
  );
  const jsCoveragePercent = (jsUsedBytes / jsTotalBytes) * 100;

  console.log('Performance Metrics:', metrics);
  console.log('JS Coverage:', `${jsCoveragePercent.toFixed(2)}%`);

  await browser.close();
}

runPerformanceTest().catch(console.error);
```

## 📋 性能优化检查清单

### 代码分割检查

- [ ] 路由级别代码分割
- [ ] 组件级别代码分割
- [ ] 第三方库代码分割
- [ ] 动态导入使用

### 懒加载检查

- [ ] 图片懒加载
- [ ] 组件懒加载
- [ ] 路由懒加载
- [ ] 资源懒加载

### 缓存策略检查

- [ ] 浏览器缓存配置
- [ ] Service Worker缓存
- [ ] API响应缓存
- [ ] 静态资源缓存

### 性能监控检查

- [ ] Core Web Vitals监控
- [ ] 性能指标收集
- [ ] 性能报告生成
- [ ] 性能告警设置

## ⚠️ 注意事项

1. **渐进式优化**: 逐步实施优化策略，避免一次性大改
2. **性能测试**: 每次优化后都要进行性能测试
3. **用户体验**: 优化不能影响用户体验
4. **兼容性**: 确保优化后的代码在各种环境下都能正常工作
5. **监控**: 持续监控性能指标，及时发现问题

## 🎯 最佳实践

### 1. 代码分割

- 按路由分割代码
- 按功能分割代码
- 按用户权限分割代码
- 按设备类型分割代码

### 2. 懒加载

- 图片懒加载
- 组件懒加载
- 路由懒加载
- 资源懒加载

### 3. 缓存策略

- 静态资源长期缓存
- API响应短期缓存
- 用户数据本地缓存
- 服务端缓存

### 4. 性能监控

- 实时性能监控
- 性能指标收集
- 性能报告生成
- 性能告警设置

**记住: 好的性能是用户体验的基础，持续的性能优化确保应用的高可用性和用户满意度。**

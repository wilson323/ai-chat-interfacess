# 测试体系完善方案

## 🎯 测试目标

### 1. 测试覆盖率

- **单元测试覆盖率**: ≥ 80%
- **集成测试覆盖率**: ≥ 60%
- **E2E测试覆盖率**: ≥ 40%
- **关键业务逻辑覆盖率**: ≥ 90%

### 2. 测试质量

- **测试稳定性**: 95%以上通过率
- **测试执行时间**: 单元测试 < 30秒，集成测试 < 5分钟，E2E测试 < 15分钟
- **测试维护性**: 测试代码可读性强，易于维护
- **测试可重复性**: 测试结果一致，无随机性

## 🏗️ 测试架构

### 1. 测试分层

```typescript
// 测试金字塔
// E2E测试 (10%)
// 集成测试 (20%)
// 单元测试 (70%)
```

### 2. 测试类型

- **单元测试**: 测试单个函数、组件、工具函数
- **集成测试**: 测试模块间交互、API接口、数据库操作
- **E2E测试**: 测试完整用户流程、跨浏览器兼容性
- **性能测试**: 测试性能指标、负载测试
- **安全测试**: 测试安全漏洞、权限控制

## 🔧 技术实现

### 1. 测试框架配置

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  transform: {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        tsconfig: 'tsconfig.json',
      },
    ],
  },
  testMatch: ['**/__tests__/**/*.test.(ts|tsx)', '**/tests/**/*.test.(ts|tsx)'],
  collectCoverageFrom: [
    'lib/**/*.{ts,tsx}',
    'components/**/*.{ts,tsx}',
    'app/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  testTimeout: 10000,
  maxWorkers: '50%',
  verbose: true,
};
```

### 2. Playwright配置

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/results.xml' }],
  ],
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile-safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    stdout: 'pipe',
    stderr: 'pipe',
  },
});
```

### 3. 测试工具配置

```typescript
// jest.setup.js
import '@testing-library/jest-dom';
import { TextEncoder, TextDecoder } from 'util';

// 模拟环境变量
process.env.NODE_ENV = 'test';
process.env.NEXT_PUBLIC_API_URL = 'http://localhost:3000/api';

// 模拟全局对象
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;

// 模拟fetch
global.fetch = jest.fn();

// 模拟localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock;

// 模拟sessionStorage
const sessionStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.sessionStorage = sessionStorageMock;

// 模拟IntersectionObserver
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// 模拟ResizeObserver
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// 模拟matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});
```

## 📦 测试工具库

### 1. 单元测试工具

```typescript
// lib/test-utils/index.ts
import { render, RenderOptions } from '@testing-library/react'
import { ReactElement } from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { AppProvider } from '@/context/agent-context'

// 创建测试用的QueryClient
const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
})

// 自定义渲染函数
const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => {
  const queryClient = createTestQueryClient()

  const Wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <AppProvider>
        {children}
      </AppProvider>
    </QueryClientProvider>
  )

  return render(ui, { wrapper: Wrapper, ...options })
}

// 重新导出所有内容
export * from '@testing-library/react'
export { customRender as render }
```

### 2. 集成测试工具

```typescript
// lib/test-utils/integration.ts
import { createClient } from '@supabase/supabase-js';
import { appConfig } from '@/lib/config';

// 创建测试数据库客户端
export const createTestDBClient = () => {
  return createClient(
    process.env.TEST_DATABASE_URL ||
      'postgresql://test:test@localhost:5432/test',
    {
      auth: {
        persistSession: false,
      },
    }
  );
};

// 创建测试Redis客户端
export const createTestRedisClient = () => {
  return {
    get: jest.fn(),
    set: jest.fn(),
    del: jest.fn(),
    exists: jest.fn(),
    expire: jest.fn(),
    ttl: jest.fn(),
    flushdb: jest.fn(),
  };
};

// 测试数据工厂
export const testDataFactory = {
  createUser: (overrides = {}) => ({
    id: 'test-user-id',
    name: 'Test User',
    email: 'test@example.com',
    ...overrides,
  }),

  createAgent: (overrides = {}) => ({
    id: 'test-agent-id',
    name: 'Test Agent',
    type: 'chat',
    isPublished: true,
    ...overrides,
  }),

  createMessage: (overrides = {}) => ({
    id: 'test-message-id',
    content: 'Test message',
    role: 'user',
    timestamp: Date.now(),
    ...overrides,
  }),
};

// 清理测试数据
export const cleanupTestData = async () => {
  const db = createTestDBClient();
  const redis = createTestRedisClient();

  // 清理数据库
  await db.from('users').delete().neq('id', '');
  await db.from('agents').delete().neq('id', '');
  await db.from('messages').delete().neq('id', '');

  // 清理Redis
  await redis.flushdb();
};
```

### 3. E2E测试工具

```typescript
// lib/test-utils/e2e.ts
import { Page, expect } from '@playwright/test';

// 页面对象模型
export class LoginPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/admin/login');
  }

  async login(username: string, password: string) {
    await this.page.fill('#username', username);
    await this.page.fill('#password', password);
    await this.page.click('button[type="submit"]');
  }

  async expectLoginSuccess() {
    await expect(this.page).toHaveURL('/admin');
    await expect(this.page.locator('text=退出登录')).toBeVisible();
  }

  async expectLoginError() {
    await expect(this.page.locator('text=用户名或密码错误')).toBeVisible();
  }
}

export class ChatPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/');
  }

  async sendMessage(message: string) {
    await this.page.fill('textarea', message);
    await this.page.keyboard.press('Enter');
  }

  async expectMessage(message: string) {
    await expect(this.page.locator('.message-bubble-user')).toContainText(
      message
    );
  }

  async expectResponse() {
    await expect(
      this.page.locator('.message-bubble-assistant').nth(1)
    ).toBeVisible();
  }
}

// 测试助手函数
export const testHelpers = {
  async waitForPageLoad(page: Page) {
    await page.waitForLoadState('networkidle');
  },

  async takeScreenshot(page: Page, name: string) {
    await page.screenshot({ path: `test-results/screenshots/${name}.png` });
  },

  async mockAPIResponse(page: Page, url: string, response: any) {
    await page.route(url, route => {
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(response),
      });
    });
  },
};
```

## 🧪 测试用例实现

### 1. 单元测试用例

```typescript
// __tests__/lib/utils.test.ts
import { formatDate, validateEmail, debounce } from '@/lib/utils';

describe('Utils', () => {
  describe('formatDate', () => {
    it('应该正确格式化日期', () => {
      const date = new Date('2024-01-01T00:00:00Z');
      expect(formatDate(date)).toBe('2024-01-01');
    });

    it('应该处理无效日期', () => {
      expect(formatDate(new Date('invalid'))).toBe('Invalid Date');
    });
  });

  describe('validateEmail', () => {
    it('应该验证有效邮箱', () => {
      expect(validateEmail('test@example.com')).toBe(true);
    });

    it('应该拒绝无效邮箱', () => {
      expect(validateEmail('invalid-email')).toBe(false);
    });
  });

  describe('debounce', () => {
    it('应该防抖函数调用', async () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 100);

      debouncedFn();
      debouncedFn();
      debouncedFn();

      await new Promise(resolve => setTimeout(resolve, 150));

      expect(mockFn).toHaveBeenCalledTimes(1);
    });
  });
});
```

### 2. 组件测试用例

```typescript
// __tests__/components/chat-container.test.tsx
import { render, screen, fireEvent, waitFor } from '@/lib/test-utils'
import { ChatContainer } from '@/components/chat-container'

// Mock依赖
jest.mock('@/lib/services/agent-service', () => ({
  fetchAgents: jest.fn().mockResolvedValue([
    { id: '1', name: 'Test Agent', type: 'chat' }
  ])
}))

describe('ChatContainer', () => {
  it('应该渲染聊天容器', () => {
    render(<ChatContainer />)

    expect(screen.getByRole('main')).toBeInTheDocument()
    expect(screen.getByPlaceholderText('输入消息...')).toBeInTheDocument()
  })

  it('应该发送消息', async () => {
    render(<ChatContainer />)

    const input = screen.getByPlaceholderText('输入消息...')
    const sendButton = screen.getByRole('button', { name: '发送' })

    fireEvent.change(input, { target: { value: 'Hello' } })
    fireEvent.click(sendButton)

    await waitFor(() => {
      expect(screen.getByText('Hello')).toBeInTheDocument()
    })
  })

  it('应该显示加载状态', async () => {
    render(<ChatContainer />)

    const input = screen.getByPlaceholderText('输入消息...')
    fireEvent.change(input, { target: { value: 'Hello' } })
    fireEvent.keyDown(input, { key: 'Enter' })

    expect(screen.getByText('发送中...')).toBeInTheDocument()
  })
})
```

### 3. API测试用例

```typescript
// __tests__/api/agents.test.ts
import { createMocks } from 'node-mocks-http';
import { GET, POST } from '@/app/api/agents/route';
import { dbPool } from '@/lib/db/connection-pool';

// Mock数据库
jest.mock('@/lib/db/connection-pool', () => ({
  dbPool: {
    getInstance: jest.fn().mockReturnValue({
      query: jest.fn(),
      transaction: jest.fn(),
    }),
  },
}));

describe('/api/agents', () => {
  describe('GET', () => {
    it('应该返回智能体列表', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/agents',
      });

      // Mock数据库查询结果
      const mockAgents = [{ id: '1', name: 'Test Agent', type: 'chat' }];

      dbPool.getInstance().query.mockResolvedValue(mockAgents);

      await GET(req as any, res as any);

      expect(res._getStatusCode()).toBe(200);
      expect(JSON.parse(res._getData())).toEqual({
        success: true,
        data: mockAgents,
      });
    });

    it('应该处理数据库错误', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        url: '/api/agents',
      });

      dbPool.getInstance().query.mockRejectedValue(new Error('Database error'));

      await GET(req as any, res as any);

      expect(res._getStatusCode()).toBe(500);
      expect(JSON.parse(res._getData())).toEqual({
        success: false,
        error: expect.objectContaining({
          code: 'DATABASE_ERROR',
          message: '数据库操作失败',
        }),
      });
    });
  });

  describe('POST', () => {
    it('应该创建新智能体', async () => {
      const { req, res } = createMocks({
        method: 'POST',
        url: '/api/agents',
        body: {
          name: 'New Agent',
          type: 'chat',
        },
      });

      const mockAgent = { id: '2', name: 'New Agent', type: 'chat' };
      dbPool.getInstance().query.mockResolvedValue([mockAgent]);

      await POST(req as any, res as any);

      expect(res._getStatusCode()).toBe(201);
      expect(JSON.parse(res._getData())).toEqual({
        success: true,
        data: mockAgent,
      });
    });
  });
});
```

### 4. E2E测试用例

```typescript
// tests/chat-flow.e2e.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage, ChatPage, testHelpers } from '@/lib/test-utils/e2e';

test.describe('聊天流程测试', () => {
  test('完整聊天流程', async ({ page }) => {
    const chatPage = new ChatPage(page);

    // 访问聊天页面
    await chatPage.goto();
    await testHelpers.waitForPageLoad(page);

    // 发送消息
    await chatPage.sendMessage('你好');
    await chatPage.expectMessage('你好');

    // 等待响应
    await chatPage.expectResponse();

    // 验证响应内容
    const response = page.locator('.message-bubble-assistant').nth(1);
    await expect(response).toBeVisible();

    // 截图
    await testHelpers.takeScreenshot(page, 'chat-flow');
  });

  test('智能体切换', async ({ page }) => {
    const chatPage = new ChatPage(page);

    await chatPage.goto();
    await testHelpers.waitForPageLoad(page);

    // 切换智能体
    await page.click('[data-testid="agent-selector"]');
    await page.click('[data-testid="agent-option-2"]');

    // 验证智能体切换
    await expect(page.locator('[data-testid="current-agent"]')).toContainText(
      'Agent 2'
    );

    // 发送消息
    await chatPage.sendMessage('测试智能体切换');
    await chatPage.expectMessage('测试智能体切换');
  });
});
```

## 📊 测试报告和监控

### 1. 测试覆盖率报告

```typescript
// scripts/test-coverage.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// 运行测试并生成覆盖率报告
function generateCoverageReport() {
  try {
    // 运行单元测试
    execSync('npm run test:unit -- --coverage', { stdio: 'inherit' });

    // 运行集成测试
    execSync('npm run test:integration -- --coverage', { stdio: 'inherit' });

    // 合并覆盖率报告
    const unitCoverage = JSON.parse(
      fs.readFileSync('coverage/coverage-final.json', 'utf8')
    );
    const integrationCoverage = JSON.parse(
      fs.readFileSync('coverage-integration/coverage-final.json', 'utf8')
    );

    // 生成合并报告
    const mergedCoverage = mergeCoverageReports(
      unitCoverage,
      integrationCoverage
    );
    fs.writeFileSync(
      'coverage/coverage-merged.json',
      JSON.stringify(mergedCoverage, null, 2)
    );

    console.log('✅ 覆盖率报告生成完成');
  } catch (error) {
    console.error('❌ 覆盖率报告生成失败:', error);
    process.exit(1);
  }
}

function mergeCoverageReports(unit, integration) {
  // 合并逻辑
  return { ...unit, ...integration };
}

generateCoverageReport();
```

### 2. 测试性能监控

```typescript
// lib/test-utils/performance.ts
import { performance } from 'perf_hooks';

export class TestPerformanceMonitor {
  private metrics: Array<{
    testName: string;
    duration: number;
    timestamp: number;
  }> = [];

  startTest(testName: string) {
    performance.mark(`${testName}-start`);
  }

  endTest(testName: string) {
    performance.mark(`${testName}-end`);
    performance.measure(testName, `${testName}-start`, `${testName}-end`);

    const measure = performance.getEntriesByName(testName)[0];
    this.metrics.push({
      testName,
      duration: measure.duration,
      timestamp: Date.now(),
    });
  }

  getMetrics() {
    return this.metrics;
  }

  getSlowTests(threshold: number = 1000) {
    return this.metrics.filter(m => m.duration > threshold);
  }

  generateReport() {
    const totalTests = this.metrics.length;
    const totalDuration = this.metrics.reduce((sum, m) => sum + m.duration, 0);
    const averageDuration = totalDuration / totalTests;
    const slowTests = this.getSlowTests();

    return {
      totalTests,
      totalDuration,
      averageDuration,
      slowTests: slowTests.length,
      slowTestDetails: slowTests,
    };
  }
}

export const testPerformanceMonitor = new TestPerformanceMonitor();
```

## 📋 测试检查清单

### 单元测试检查

- [ ] 函数测试覆盖
- [ ] 组件测试覆盖
- [ ] 工具函数测试覆盖
- [ ] 边界条件测试
- [ ] 错误处理测试

### 集成测试检查

- [ ] API接口测试
- [ ] 数据库操作测试
- [ ] 缓存操作测试
- [ ] 外部服务集成测试
- [ ] 中间件测试

### E2E测试检查

- [ ] 用户流程测试
- [ ] 跨浏览器测试
- [ ] 移动端测试
- [ ] 性能测试
- [ ] 可访问性测试

### 测试质量检查

- [ ] 测试稳定性
- [ ] 测试执行时间
- [ ] 测试维护性
- [ ] 测试可重复性
- [ ] 测试覆盖率

## ⚠️ 注意事项

1. **测试隔离**: 每个测试应该独立运行，不依赖其他测试
2. **测试数据**: 使用测试专用的数据和环境
3. **测试清理**: 测试完成后清理测试数据
4. **测试稳定性**: 避免随机性和时间依赖
5. **测试维护**: 保持测试代码的可读性和可维护性

## 🎯 最佳实践

### 1. 测试编写

- 遵循AAA模式（Arrange, Act, Assert）
- 使用描述性的测试名称
- 保持测试简单和专注
- 使用适当的断言

### 2. 测试组织

- 按功能模块组织测试
- 使用测试套件和分组
- 保持测试文件结构清晰
- 使用测试工具和助手

### 3. 测试维护

- 定期更新测试
- 重构测试代码
- 监控测试性能
- 保持测试文档更新

**记住: 好的测试体系是软件质量的基础，完善的测试体系确保软件的可靠性和可维护性。**

---
globs: *.ts,*.tsx,*.js,*.jsx
description: 安全的自动化修复和代码质量保障
---

# 安全的自动化修复和代码质量保障

## 核心安全原则

### 1. 零破坏性修复
- 所有自动化修复必须保证功能不变
- 修复前后UI显示效果完全一致
- 不修改业务逻辑和核心功能
- 只修复明确的语法和规范问题

### 2. 渐进式修复策略
```javascript
// 修复流程
1. 检测问题 → 2. 创建备份 → 3. 安全修复 → 4. 验证结果 → 5. 确认提交
```

### 3. 多重验证机制
- 语法验证：确保修复后语法正确
- 类型验证：确保TypeScript类型检查通过
- 构建验证：确保项目能够正常构建
- 测试验证：确保所有测试通过
- 功能验证：确保UI显示效果一致

## 安全修复规则

### HTML实体编码修复
```typescript
// 安全的修复规则
const safeHtmlEntityFixes = {
  // 只修复明确的HTML实体编码
  '&lt;': "{'<'}",      // 小于号
  '&gt;': "{'>'}",      // 大于号
  '&amp;': "{'&'}",     // 和号
  '&quot;': '{"'}"',    // 双引号
  '&#x27;': "{'\\''}"   // 单引号
};

// 修复前验证
function validateBeforeFix(content: string): boolean {
  // 1. 检查是否真的存在HTML实体编码
  const hasHtmlEntities = /&[a-zA-Z0-9#]+;/.test(content);

  // 2. 检查是否在JSX上下文中
  const isInJsx = /<[^>]*>.*&[a-zA-Z0-9#]+;.*<\/[^>]*>/.test(content);

  return hasHtmlEntities && isInJsx;
}

// 修复后验证
function validateAfterFix(content: string): boolean {
  // 1. 检查语法是否正确
  const hasValidJsx = /<[^>]*>.*\{'[^']*'\}.*<\/[^>]*>/.test(content);

  // 2. 检查是否还有HTML实体编码
  const hasNoHtmlEntities = !/&[a-zA-Z0-9#]+;/.test(content);

  return hasValidJsx && hasNoHtmlEntities;
}
```

### 类型安全修复
```typescript
// 类型修复规则
const typeSafetyFixes = {
  // 添加明确的类型注解
  'const ': 'const ',
  'let ': 'let ',
  'var ': 'var ',

  // 修复any类型
  ': any': ': unknown',
  'any[]': 'unknown[]',
  'any)': 'unknown)'
};

// 类型修复验证
function validateTypeFix(content: string): boolean {
  // 1. 检查是否还有any类型
  const hasAnyType = /:\s*any\b/.test(content);

  // 2. 检查类型注解是否完整
  const hasIncompleteTypes = /const\s+\w+\s*=/.test(content) &&
                            !/const\s+\w+\s*:\s*\w+\s*=/.test(content);

  return !hasAnyType && !hasIncompleteTypes;
}
```

## 自动化修复安全机制

### 1. 备份机制
```bash
#!/bin/bash
# 自动备份脚本
echo "📦 创建修复前备份..."

# 创建Git备份
git add -A
git commit -m "backup: before auto-fix $(date)"

# 创建文件备份
mkdir -p backups/$(date +%Y%m%d_%H%M%S)
cp -r src/ backups/$(date +%Y%m%d_%H%M%S)/

echo "✅ 备份创建成功"
```

### 2. 验证机制
```javascript
// 修复后验证
async function validateFix() {
  const validations = [
    // 1. 语法检查
    () => execSync('npm run check-types'),

    // 2. 构建检查
    () => execSync('npm run build'),

    // 3. 测试检查
    () => execSync('npm run test'),

    // 4. 代码质量检查
    () => execSync('npm run lint')
  ];

  for (const validation of validations) {
    try {
      validation();
    } catch (error) {
      throw new Error(`验证失败: ${error.message}`);
    }
  }
}
```

### 3. 回滚机制
```javascript
// 自动回滚
function rollbackFix() {
  try {
    // 回滚Git更改
    execSync('git reset --hard HEAD~1');

    // 恢复文件备份
    const latestBackup = getLatestBackup();
    if (latestBackup) {
      execSync(`cp -r ${latestBackup}/* src/`);
    }

    console.log('✅ 回滚成功');
  } catch (error) {
    console.error('❌ 回滚失败:', error.message);
  }
}
```

## 修复范围限制

### 允许修复的问题
- ✅ HTML实体编码问题
- ✅ 明显的语法错误
- ✅ 类型注解缺失
- ✅ 代码格式问题
- ✅ 导入导出规范

### 禁止修复的问题
- ❌ 业务逻辑修改
- ❌ 算法实现变更
- ❌ 数据结构修改
- ❌ API接口变更
- ❌ 用户界面布局

### 需要人工确认的问题
- ⚠️ 复杂的类型推断
- ⚠️ 性能优化建议
- ⚠️ 架构重构建议
- ⚠️ 安全相关修改
- ⚠️ 第三方库升级

## 质量门控

### 修复前检查
```javascript
const preFixChecks = [
  // 1. 确认问题存在
  'validateProblemExists',

  // 2. 确认修复方案
  'validateFixPlan',

  // 3. 确认影响范围
  'validateImpactScope',

  // 4. 确认安全性
  'validateSafety'
];
```

### 修复后检查
```javascript
const postFixChecks = [
  // 1. 语法正确性
  'validateSyntax',

  // 2. 类型安全性
  'validateTypes',

  // 3. 功能完整性
  'validateFunctionality',

  // 4. 性能影响
  'validatePerformance'
];
```

## 监控和告警

### 修复监控
```javascript
// 修复过程监控
const fixMonitor = {
  // 监控修复进度
  trackProgress: (step, status) => {
    console.log(`[${new Date().toISOString()}] ${step}: ${status}`);
  },

  // 监控修复结果
  trackResult: (file, before, after) => {
    console.log(`修复文件: ${file}`);
    console.log(`修复前: ${before}`);
    console.log(`修复后: ${after}`);
  },

  // 监控错误
  trackError: (error, context) => {
    console.error(`修复错误: ${error.message}`);
    console.error(`上下文: ${context}`);
  }
};
```

### 质量告警
```javascript
// 质量告警系统
const qualityAlerts = {
  // 修复失败告警
  fixFailed: (file, error) => {
    console.error(`❌ 修复失败: ${file}`);
    console.error(`错误: ${error.message}`);
  },

  // 验证失败告警
  validationFailed: (step, error) => {
    console.error(`❌ 验证失败: ${step}`);
    console.error(`错误: ${error.message}`);
  },

  // 回滚告警
  rollbackTriggered: (reason) => {
    console.warn(`⚠️  触发回滚: ${reason}`);
  }
};
```

## 最佳实践

### 1. 修复前准备
- 创建完整备份
- 确认修复范围
- 验证修复方案
- 准备回滚计划

### 2. 修复过程
- 逐步修复，逐步验证
- 记录修复过程
- 监控修复结果
- 及时处理异常

### 3. 修复后验证
- 全面功能测试
- 性能影响评估
- 代码质量检查
- 团队代码审查

### 4. 持续改进
- 收集修复反馈
- 优化修复策略
- 更新修复规则
- 提升修复质量

## 检查清单

### 修复前检查
- [ ] 问题确认和范围界定
- [ ] 修复方案设计和验证
- [ ] 备份创建和回滚准备
- [ ] 影响范围评估
- [ ] 安全风险评估

### 修复过程检查
- [ ] 逐步修复和验证
- [ ] 修复过程监控
- [ ] 异常处理和恢复
- [ ] 修复结果记录
- [ ] 质量门控检查

### 修复后检查
- [ ] 功能完整性验证
- [ ] 性能影响评估
- [ ] 代码质量检查
- [ ] 团队代码审查
- [ ] 文档更新

参考配置文件：[package.json](mdc:package.json), [tsconfig.json](mdc:tsconfig.json)
